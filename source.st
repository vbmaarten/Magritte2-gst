SystemOrganization addCategory: #'Magritte-Model-Accessor'!SystemOrganization addCategory: #'Magritte-Model-Core'!SystemOrganization addCategory: #'Magritte-Model-Description'!SystemOrganization addCategory: #'Magritte-Model-Exception'!SystemOrganization addCategory: #'Magritte-Model-Memento'!SystemOrganization addCategory: #'Magritte-Model-Models'!SystemOrganization addCategory: #'Magritte-Model-Utility'!SystemOrganization addCategory: #'Magritte-Model-Visitor'!!UndefinedObject methodsFor: '*magritte-model-converting' stamp: 'lr 4/10/2008 13:35'!asAccessor	^ MANullAccessor new! !!UndefinedObject methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!label	^ 'n/a'! !!GRPackage class methodsFor: '*magritte-model' stamp: 'lr 2/18/2010 10:29'!magritteModel	^ self new		name: 'Magritte-Model';		description: 'The Magritte metamodel.';		addDependency: 'Grease-Core';		url: #magritteUrl;		yourself! !!GRPackage methodsFor: '*magritte-model' stamp: 'lr 2/16/2010 09:15'!magritteUrl	^ 'http://source.lukas-renggli.ch/magritte2'! !!Integer methodsFor: '*magritte-model-converting' stamp: 'lr 3/9/2006 11:31'!asFileSize	#( 'B' 'KB' 'MB' 'GB' 'TB' 'PB' 'EB' 'ZB' 'YB' )		inject: self		into: [ :value :each |			value < 1024				ifFalse: [ value // 1024 ]				ifTrue: [ ^ value asString , ' ' , each ] ]! !!String methodsFor: '*magritte-model-testing' stamp: 'lr 3/9/2006 11:31'!matches: aString	aString isEmpty ifTrue: [ ^ true ].	^ (aString includesAnyOf: '*#')		ifTrue: [ aString match: self ]		ifFalse: [ self includesSubstring: aString caseSensitive: false ]! !!Collection methodsFor: '*magritte-model' stamp: 'lr 3/9/2006 11:31'!asMultilineString	^ String streamContents: [ :stream |		self			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream nextPut: Character cr ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'lr 3/9/2006 11:31'!copyWithAll: aCollection	^ self copy		addAll: aCollection;		yourself! !!Collection methodsFor: '*magritte-model' stamp: 'jf 9/18/2009 11:01'!copyWithoutFirst: anObject	| done |	done := false.	^ self reject: [ :each |		(each = anObject			and: [ done not ])				and: [ done := true ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'lr 7/6/2010 18:32'!copyWithoutFirstOccurrenceOf: anObject	| done |	done := false.	^ self reject: [ :each |		each = anObject			and: [ done not			and: [ done := true ] ] ]! !GRError subclass: #MAError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Exception'!!MAError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I represent a generic Magritte error.!MAError subclass: #MAPropertyError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Exception'!MAError subclass: #MAReadError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Exception'!!MAReadError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I am an error that gets raised when there is problem reading serialized data.!MAError subclass: #MAValidationError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Exception'!!MAValidationError commentStamp: 'lr 5/17/2006 15:15' prior: 0!I am a generic validation error. I reference the description that caused the validation error.!MAValidationError subclass: #MAConditionError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Exception'!!MAConditionError commentStamp: 'lr 5/30/2006 23:33' prior: 0!I am an error that is raised whenever a user-defined condition is failing.!MAValidationError subclass: #MAConflictError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Exception'!!MAConflictError commentStamp: 'lr 5/17/2006 15:16' prior: 0!I am an error that is raised whenever there is an edit conflict.!MAValidationError subclass: #MAKindError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Exception'!!MAKindError commentStamp: 'lr 5/17/2006 15:16' prior: 0!I am an error that is raised whenever a description is applied to the wrong type of data.!MAValidationError subclass: #MAMultipleErrors	instanceVariableNames: 'collection'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Exception'!!MAMultipleErrors commentStamp: 'lr 5/17/2006 15:18' prior: 0!I am an error that is raised whenever there are multiple validation rules failing.!!MAMultipleErrors class methodsFor: 'instance creation' stamp: 'lr 4/10/2008 14:12'!description: aDescription errors: aCollection signal: aString 	^ self new		setDescription: aDescription;		setCollection: aCollection;		signal: aString;		yourself! !!MAMultipleErrors methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!collection	^ collection! !!MAMultipleErrors methodsFor: 'printing' stamp: 'lr 11/14/2006 17:55'!printOn: aStream	self collection		do: [ :each | aStream print: each ]		separatedBy: [ aStream nextPut: Character cr ]! !!MAMultipleErrors methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setCollection: aCollection	collection := aCollection! !MAValidationError subclass: #MARangeError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Exception'!!MARangeError commentStamp: 'lr 5/17/2006 15:17' prior: 0!I am an error that is raised whenever a described value is out of bounds.!MAValidationError subclass: #MARequiredError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Exception'!!MARequiredError commentStamp: 'lr 5/17/2006 15:17' prior: 0!I am an error that is raised whenever a required value is not supplied.!!MAValidationError class methodsFor: 'instance creation' stamp: 'lr 4/10/2008 14:12'!description: aDescription signal: aString 	^ self new		setDescription: aDescription;		signal: aString;		yourself! !!MAValidationError methodsFor: 'printing' stamp: 'lr 4/30/2008 22:32'!printOn: aStream	(self tag isDescription and: [ self tag label notNil ])		ifTrue: [ aStream nextPutAll: self tag label; nextPutAll: ': ' ].	aStream nextPutAll: self messageText! !!MAValidationError methodsFor: 'initialization' stamp: 'lr 9/3/2008 14:32'!setDescription: aDescription	self tag: aDescription! !MAError subclass: #MAWriteError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Exception'!!MAWriteError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I am an error that gets raised when there is problem writing serialized data.!GRObject subclass: #MABasicObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Core'!MABasicObject subclass: #MAAdaptiveModel	instanceVariableNames: 'description values'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Models'!!MAAdaptiveModel commentStamp: 'lr 6/2/2006 00:30' prior: 0!I am an adaptive model referencing a dynamic description of myself and a dictionary mapping those descriptions to actual values.!!MAAdaptiveModel class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!description: aDescription	^ self new		description: aDescription;		yourself! !!MAAdaptiveModel methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:32'!defaultDescription	^ MAContainer new! !!MAAdaptiveModel methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:32'!defaultDictionary	^ Dictionary new! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'lr 5/17/2006 14:13'!description	"Answer the description of the receiver."	^ description! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'lr 6/2/2006 00:12'!description: aDescription	description := aDescription! !!MAAdaptiveModel methodsFor: 'initialization' stamp: 'jf 9/16/2009 13:17'!initialize	super initialize.	self description: self defaultDescription.	self values: self defaultDictionary! !!MAAdaptiveModel methodsFor: 'model' stamp: 'lr 4/10/2007 21:23'!readUsing: aDescription	"Answer the actual value of ==aDescription== within the receiver, ==nil== if not present."	^ self values at: aDescription ifAbsent: [ nil ]! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'lr 5/17/2006 14:14'!values	"Answer a dictionary mapping description to actual values."	^ values! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'lr 6/2/2006 00:12'!values: aDictionary	values := aDictionary! !!MAAdaptiveModel methodsFor: 'model' stamp: 'lr 4/10/2007 21:23'!write: anObject using: aDescription	"Set ==anObject== to be that actual value of the receiver for ==aDescription==."	self values at: aDescription put: anObject! !!MABasicObject class methodsFor: 'error handling' stamp: 'jf 9/16/2009 13:16'!defaultErrorClass	^ MAError! !MABasicObject subclass: #MADescriptionBuilder	instanceVariableNames: 'cache'	classVariableNames: 'Default'	poolDictionaries: ''	category: 'Magritte-Model-Utility'!!MADescriptionBuilder class methodsFor: 'accessing' stamp: 'lr 7/10/2009 16:33'!default	^ Default ifNil: [ Default := MANamedBuilder new ]! !!MADescriptionBuilder class methodsFor: 'accessing' stamp: 'lr 3/27/2006 13:31'!default: aBuilder	Default := aBuilder! !!MADescriptionBuilder class methodsFor: 'building' stamp: 'lr 3/27/2006 13:29'!for: anObject	^ self default for: anObject! !!MADescriptionBuilder class methodsFor: 'initialization' stamp: 'lr 7/5/2009 10:52'!unload	self default finalize.	self default: nil! !!MADescriptionBuilder methodsFor: 'private' stamp: 'lr 2/14/2007 09:09'!build: anObject	self subclassResponsibility! !!MADescriptionBuilder methodsFor: 'initialization' stamp: 'lr 3/27/2006 13:55'!finalize	super finalize.	self flush; unregister! !!MADescriptionBuilder methodsFor: 'actions' stamp: 'lr 3/27/2006 13:41'!flush	cache := IdentityDictionary new! !!MADescriptionBuilder methodsFor: 'accessing' stamp: 'lr 9/12/2007 17:26'!for: anObject	^ cache at: anObject ifAbsentPut: [ self build: anObject ]! !!MADescriptionBuilder methodsFor: 'initialization' stamp: 'jf 9/16/2009 13:20'!initialize	super initialize.	self flush; register! !!MADescriptionBuilder methodsFor: 'events' stamp: 'jf 9/16/2009 17:26'!modified	self flush! !!MADescriptionBuilder methodsFor: 'actions' stamp: 'jf 9/30/2009 00:19'!register	GRPlatform current 		magritteRegister: self		forMethodChangeNotificationsUsing: #modified! !!MADescriptionBuilder methodsFor: 'actions' stamp: 'jf 9/30/2009 00:19'!unregister	GRPlatform current 		magritteUnregister: self		forMethodChangeNotificationsUsing: #modified! !MADescriptionBuilder subclass: #MANamedBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Utility'!!MANamedBuilder commentStamp: 'lr 4/10/2007 21:09' prior: 0!I dynamically build container descriptions from class-side methods using a simple naming convention for the selector names:# The method ==#defaultContainer== is called to retrieve the container instance.# All the unary methods starting with the selector ==#description== are called and should return a valid description to be added to the container.# All the keyword messages with one argument having a prefix of a method selected in step 2 will be called with the original description to further refine its definition.!!MANamedBuilder methodsFor: 'private' stamp: 'NickAger 8/24/2011 13:36'!build: anObject	| selectors container |	selectors := SortedCollection withAll: (anObject class allSelectors select: [ :each | each isDescriptionSelector ]).	container := self build: anObject for: self containerSelector in: selectors.	^ (selectors select: [ :each | each isDescriptionDefinition ])		inject: (cache at: anObject put: container)		into: [ :result :each |			self containerSelector = each ifFalse: [				| description |				description := self build: anObject for: each in: selectors.				description isDescription					ifTrue: [ result add: description ] ].			result ]! !!MANamedBuilder methodsFor: 'private' stamp: 'lr 8/23/2008 11:51'!build: anObject for: aSelector in: aCollection	^ (aCollection select: [ :each | each isDescriptionExtension: aSelector ])		inject: (anObject perform: aSelector)		into: [ :result :each | 			result isNil 				ifFalse: [ anObject perform: each with: result ] ]! !!MANamedBuilder methodsFor: 'configuration' stamp: 'lr 2/14/2007 09:03'!containerSelector	^ #descriptionContainer! !MABasicObject subclass: #MAFileModel	instanceVariableNames: 'filename mimetype filesize'	classVariableNames: 'MimeTypes'	poolDictionaries: ''	category: 'Magritte-Model-Models'!!MAFileModel commentStamp: 'lr 9/28/2007 08:04' prior: 0!I represent a file with filename, mimetype and contents within the Magritte framework.There are different file-models that you can use with Magritte. The idea is that you set the ==#kind:== of an MAFileDescription to one of the subclasses of ==*MAFileModel*==.!!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMimeType	^ 'application/octet-stream'! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'lr 4/9/2009 09:57'!defaultMimeTypes	^ #( '323' 'text/h323' 'acx' 'application/internet-property-stream' 'ai' 'application/postscript' 'aif' 'audio/x-aiff' 'aifc' 'audio/x-aiff' 'aiff' 'audio/x-aiff' 'asc' 'text/plain' 'asf' 'video/x-ms-asf' 'asr' 'video/x-ms-asf' 'asx' 'video/x-ms-asf' 'au' 'audio/basic' 'avi' 'video/x-msvideo' 'axs' 'application/olescript' 'bas' 'text/plain' 'bcpio' 'application/x-bcpio' 'bin' 'application/octet-stream' 'bmp' 'image/bmp' 'c' 'text/plain' 'cat' 'application/vnd.ms-pkiseccat' 'cc' 'text/plain' 'ccad' 'application/clariscad' 'cdf' 'application/x-netcdf' 'cer' 'application/x-x509-ca-cert' 'class' 'application/octet-stream' 'clp' 'application/x-msclip' 'cmx' 'image/x-cmx' 'cod' 'image/cis-cod' 'cpio' 'application/x-cpio' 'cpt' 'application/mac-compactpro' 'crd' 'application/x-mscardfile' 'crl' 'application/pkix-crl' 'crt' 'application/x-x509-ca-cert' 'csh' 'application/x-csh' 'css' 'text/css' 'dcr' 'application/x-director' 'der' 'application/x-x509-ca-cert' 'dir' 'application/x-director' 'dll' 'application/x-msdownload' 'dms' 'application/octet-stream' 'doc' 'application/msword' 'dot' 'application/msword' 'drw' 'application/drafting' 'dtd' 'application/xml-dtd' 'dvi' 'application/x-dvi' 'dwg' 'application/acad' 'dxf' 'application/dxf' 'dxr' 'application/x-director' 'eps' 'application/postscript' 'etx' 'text/x-setext' 'evy' 'application/envoy' 'exe' 'application/octet-stream' 'ez' 'application/andrew-inset' 'f' 'text/plain' 'f90' 'text/plain' 'fif' 'application/fractals' 'fli' 'video/x-fli' 'flr' 'x-world/x-vrml' 'gif' 'image/gif' 'gtar' 'application/x-gtar' 'gz' 'application/x-gzip' 'h' 'text/plain' 'hdf' 'application/x-hdf' 'hh' 'text/plain' 'hlp' 'application/winhlp' 'hqx' 'application/mac-binhex40' 'hta' 'application/hta' 'htc' 'text/x-component' 'htm' 'text/html' 'html' 'text/html' 'htt' 'text/webviewhtml' 'ice' 'x-conference/x-cooltalk' 'ico' 'image/vnd.microsoft.icon' 'ief' 'image/ief' 'iges' 'model/iges' 'igs' 'model/iges' 'iii' 'application/x-iphone' 'ins' 'application/x-internet-signup' 'ips' 'application/x-ipscript' 'ipx' 'application/x-ipix' 'isp' 'application/x-internet-signup' 'jfif' 'image/pipeg' 'jpe' 'image/jpeg' 'jpeg' 'image/jpeg' 'jpg' 'image/jpeg' 'js' 'application/javascript' 'json' 'application/json' 'kar' 'audio/midi' 'latex' 'application/x-latex' 'lha' 'application/octet-stream' 'lsf' 'video/x-la-asf' 'lsp' 'application/x-lisp' 'lsx' 'video/x-la-asf' 'lzh' 'application/octet-stream' 'm' 'text/plain' 'm13' 'application/x-msmediaview' 'm14' 'application/x-msmediaview' 'm3u' 'audio/x-mpegurl' 'man' 'application/x-troff-man' 'mdb' 'application/x-msaccess' 'me' 'application/x-troff-me' 'mesh' 'model/mesh' 'mht' 'message/rfc822' 'mhtml' 'message/rfc822' 'mid' 'audio/midi' 'midi' 'audio/midi' 'mif' 'application/vnd.mif' 'mime' 'www/mime' 'mny' 'application/x-msmoney' 'mov' 'video/quicktime' 'movie' 'video/x-sgi-movie' 'mp2' 'audio/mpeg' 'mp3' 'audio/mpeg' 'mpa' 'video/mpeg' 'mpe' 'video/mpeg' 'mpeg' 'video/mpeg' 'mpg' 'video/mpeg' 'mpga' 'audio/mpeg' 'mpp' 'application/vnd.ms-project' 'mpv2' 'video/mpeg' 'ms' 'application/x-troff-ms' 'msh' 'model/mesh' 'mvb' 'application/x-msmediaview' 'nc' 'application/x-netcdf' 'nws' 'message/rfc822' 'oda' 'application/oda' 'ogg' 'application/ogg' 'p10' 'application/pkcs10' 'p12' 'application/x-pkcs12' 'p7b' 'application/x-pkcs7-certificates' 'p7c' 'application/x-pkcs7-mime' 'p7m' 'application/x-pkcs7-mime' 'p7r' 'application/x-pkcs7-certreqresp' 'p7s' 'application/x-pkcs7-signature' 'pbm' 'image/x-portable-bitmap' 'pdb' 'chemical/x-pdb' 'pdf' 'application/pdf' 'pfx' 'application/x-pkcs12' 'pgm' 'image/x-portable-graymap' 'pgn' 'application/x-chess-pgn' 'pko' 'application/ynd.ms-pkipko' 'pma' 'application/x-perfmon' 'pmc' 'application/x-perfmon' 'pml' 'application/x-perfmon' 'pmr' 'application/x-perfmon' 'pmw' 'application/x-perfmon' 'png' 'image/png' 'pnm' 'image/x-portable-anymap' 'pot' 'application/mspowerpoint' 'ppm' 'image/x-portable-pixmap' 'pps' 'application/mspowerpoint' 'ppt' 'application/mspowerpoint' 'ppz' 'application/mspowerpoint' 'pre' 'application/x-freelance' 'prf' 'application/pics-rules' 'prt' 'application/pro_eng' 'ps' 'application/postscript' 'pub' 'application/x-mspublisher' 'qt' 'video/quicktime' 'ra' 'audio/x-realaudio' 'ram' 'audio/x-pn-realaudio' 'ras' 'image/cmu-raster' 'rgb' 'image/x-rgb' 'rm' 'audio/x-pn-realaudio' 'rmi' 'audio/mid' 'roff' 'application/x-troff' 'rpm' 'audio/x-pn-realaudio-plugin' 'rtf' 'application/rtf' 'rtx' 'text/richtext' 'scd' 'application/x-msschedule' 'scm' 'application/x-lotusscreencam' 'sct' 'text/scriptlet' 'set' 'application/set' 'setpay' 'application/set-payment-initiation' 'setreg' 'application/set-registration-initiation' 'sgm' 'text/sgml' 'sgml' 'text/sgml' 'sh' 'application/x-sh' 'shar' 'application/x-shar' 'silo' 'model/mesh' 'sit' 'application/x-stuffit' 'skd' 'application/x-koan' 'skm' 'application/x-koan' 'skp' 'application/x-koan' 'skt' 'application/x-koan' 'smi' 'application/smil' 'smil' 'application/smil' 'snd' 'audio/basic' 'sol' 'application/solids' 'spc' 'application/x-pkcs7-certificates' 'spl' 'application/futuresplash' 'src' 'application/x-wais-source' 'sst' 'application/vnd.ms-pkicertstore' 'step' 'application/STEP' 'stl' 'application/vnd.ms-pkistl' 'stm' 'text/html' 'stp' 'application/STEP' 'sv4cpio' 'application/x-sv4cpio' 'sv4crc' 'application/x-sv4crc' 'svg' 'image/svg+xml' 'swf' 'application/x-shockwave-flash' 't' 'application/x-troff' 'tar' 'application/x-tar' 'tcl' 'application/x-tcl' 'tex' 'application/x-tex' 'texi' 'application/x-texinfo' 'texinfo' 'application/x-texinfo' 'tgz' 'application/x-compressed' 'tif' 'image/tiff' 'tiff' 'image/tiff' 'tr' 'application/x-troff' 'trm' 'application/x-msterminal' 'tsi' 'audio/TSP-audio' 'tsp' 'application/dsptype' 'tsv' 'text/tab-separated-values' 'txt' 'text/plain' 'uls' 'text/iuls' 'unv' 'application/i-deas' 'ustar' 'application/x-ustar' 'vcd' 'application/x-cdlink' 'vcf' 'text/x-vcard' 'vda' 'application/vda' 'viv' 'video/vnd.vivo' 'vivo' 'video/vnd.vivo' 'vrml' 'model/vrml' 'wav' 'audio/x-wav' 'wcm' 'application/vnd.ms-works' 'wdb' 'application/vnd.ms-works' 'wks' 'application/vnd.ms-works' 'wmf' 'application/x-msmetafile' 'wps' 'application/vnd.ms-works' 'wri' 'application/x-mswrite' 'wrl' 'model/vrml' 'wrz' 'x-world/x-vrml' 'xaf' 'x-world/x-vrml' 'xbm' 'image/x-xbitmap' 'xhtml' 'application/xhtml+xml' 'xla' 'application/vnd.ms-excel' 'xlc' 'application/vnd.ms-excel' 'xll' 'application/vnd.ms-excel' 'xlm' 'application/vnd.ms-excel' 'xls' 'application/vnd.ms-excel' 'xlt' 'application/vnd.ms-excel' 'xlw' 'application/vnd.ms-excel' 'xml' 'text/xml' 'xof' 'x-world/x-vrml' 'xpm' 'image/x-xpixmap' 'xwd' 'image/x-xwindowdump' 'xyz' 'chemical/x-pdb' 'z' 'application/x-compress' 'zip' 'application/zip' )! !!MAFileModel class methodsFor: 'initialization' stamp: 'lr 4/9/2009 09:57'!initialize	MimeTypes := Dictionary new.	1 to: self defaultMimeTypes size by: 2 do: [ :index |		MimeTypes 			at: (self defaultMimeTypes at: index)			put: (self defaultMimeTypes at: index + 1) ]! !!MAFileModel class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!mimetypeFor: aString	^ self mimetypes at: aString ifAbsent: [ self defaultMimeType ]! !!MAFileModel class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!mimetypes	^ MimeTypes! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'lr 11/3/2009 22:12'!validCharacters	"Answer a string with all the valid characters for filenames."		^ '-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'! !!MAFileModel methodsFor: 'comparing' stamp: 'lr 2/16/2007 08:49'!= anObject	^ self species = anObject species		and: [ self filename = anObject filename		and: [ self mimetype = anObject mimetype ] ]! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 10/18/2007 18:15'!contents	"Answer the contents of the file. This method is supposed to be overridden by concrete subclasses."	self subclassResponsibility! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 2/12/2007 19:06'!contents: aByteArray	"Set the contents of the receiver. This method is supposed to be overridden by concrete subclasses."	filesize := aByteArray size! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'lr 3/21/2006 19:56'!extension	"Answer the file-extension."	^ self filename copyAfterLast: $.! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 2/12/2007 19:06'!filename	"Answer the filename of the receiver."	^ filename! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 11/3/2009 22:12'!filename: aString	"Normalize the filenames. Don't just allow any stupid windows filename.'"	filename := aString isNil ifFalse: [ 		aString collect: [ :char |			(self class validCharacters includes: char)				ifTrue: [ char ]				ifFalse: [ 					char = Character space						ifTrue: [ $- ]						ifFalse: [ $_ ] ] ] ]! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'lr 1/26/2007 18:20'!filesize	"Answer the size of the file."	^ filesize! !!MAFileModel methodsFor: 'initialization' stamp: 'lr 1/14/2008 16:53'!finalize	"Cleanup after a file is removed, subclasses might require to specialize this method."		self initialize! !!MAFileModel methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ self filename hash bitXor: self mimetype hash! !!MAFileModel methodsFor: 'initialization' stamp: 'jf 9/16/2009 13:18'!initialize	super initialize.	filesize := 0.	filename := 'unknown'.	mimetype := self class defaultMimeType! !!MAFileModel methodsFor: 'testing-types' stamp: 'lr 4/10/2007 21:39'!isApplication	"Return ==true== if the mimetype of the receiver is application-data. This message will match types like: application/postscript, application/zip, application/pdf, etc."	^ self maintype = 'application'! !!MAFileModel methodsFor: 'testing-types' stamp: 'lr 4/10/2007 21:40'!isAudio	"Return ==true== if the mimetype of the receiver is audio-data. This message will match types like: audio/basic, audio/tone, audio/mpeg, etc."	^ self maintype = 'audio'! !!MAFileModel methodsFor: 'testing' stamp: 'lr 1/26/2007 18:20'!isEmpty	^ self filesize isZero! !!MAFileModel methodsFor: 'testing-types' stamp: 'lr 4/10/2007 21:40'!isImage	"Return ==true== if the mimetype of the receiver is image-data. This message will match types like: image/jpeg, image/gif, image/png, image/tiff, etc."	^ self maintype = 'image'! !!MAFileModel methodsFor: 'testing-types' stamp: 'lr 4/10/2007 21:40'!isText	"Return ==true== if the mimetype of the receiver is text-data. This message will match types like: text/plain, text/html, text/sgml, text/css, text/xml, text/richtext, etc."	^ self maintype = 'text'! !!MAFileModel methodsFor: 'testing-types' stamp: 'lr 4/10/2007 21:40'!isVideo	"Return ==true== if the mimetype of the receiver is video-data. This message will match types like: video/mpeg, video/quicktime, etc."	^ self maintype = 'video'! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!maintype	"Answer the first part of the mime-type."	^ self mimetype copyUpTo: $/! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 2/12/2007 19:06'!mimetype	"Answer the mimetype of the receiver."	^ mimetype! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!mimetype: aString	mimetype := aString! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'DamienCassou 9/23/2010 09:56'!readStream	^ self contents readStream! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!subtype	"Answer the second part of the mime-type."	^ self mimetype copyAfter: $/! !MAFileModel subclass: #MAMemoryFileModel	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Models'!!MAMemoryFileModel commentStamp: 'lr 9/28/2007 08:06' prior: 0!I represent a file using a ByteArray in the object memory. I am not practicable for big files: use me for development and testing only.!!MAMemoryFileModel methodsFor: 'comparing' stamp: 'lr 11/6/2009 15:38'!= anObject    ^ super = anObject and: [ self contents = anObject contents ]! !!MAMemoryFileModel methodsFor: 'accessing' stamp: 'lr 10/18/2007 18:22'!contents	^ contents ifNil: [ contents := ByteArray new ]! !!MAMemoryFileModel methodsFor: 'accessing' stamp: 'lr 9/30/2007 18:20'!contents: aByteArray	super contents: aByteArray.	contents := aByteArray asByteArray! !!MAMemoryFileModel methodsFor: 'initialization' stamp: 'lr 9/30/2007 18:11'!finalize	super finalize.	contents := nil! !!MAMemoryFileModel methodsFor: 'comparing' stamp: 'lr 11/6/2009 15:38'!hash	^ super hash bitXor: self contents hash! !MABasicObject subclass: #MAObject	instanceVariableNames: 'properties'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Core'!!MAObject commentStamp: 'lr 5/17/2006 14:07' prior: 0!I provide functionality available to all Magritte objects. I implement a dictionary of properties, so that extensions can easily store additional data.!MAObject subclass: #MAAccessor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Accessor'!!MAAccessor commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am the abstract superclass to all accessor strategies. Accessors are used to implement different ways of accessing (reading and writing) data from instances using a common protocol: data can be uniformly read and written using ==#readFrom:== respectively ==#write:to:==.!!MAAccessor methodsFor: 'converting' stamp: 'lr 4/10/2008 13:31'!asAccessor	^ self! !!MAAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:44'!canRead: aModel	"Test if ==aModel== can be read."	^ false! !!MAAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:44'!canWrite: aModel	"Test if ==aModel== can be written."	^ false! !!MAAccessor methodsFor: 'printing' stamp: 'lr 3/9/2006 11:31'!printOn: aStream	self storeOn: aStream! !!MAAccessor methodsFor: 'model' stamp: 'lr 5/6/2008 17:45'!read: aModel	"Read from ==aModel== using the access-strategy of the receiver."	^ nil! !!MAAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	self class storeOn: aStream.	aStream nextPutAll: ' new'! !!MAAccessor methodsFor: 'model' stamp: 'lr 5/6/2008 17:45'!write: anObject to: aModel	"Write ==anObject== to ==aModel== using the access-strategy of the receiver."! !MAAccessor subclass: #MADelegatorAccessor	instanceVariableNames: 'next'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Accessor'!!MADelegatorAccessor commentStamp: 'lr 2/14/2008 09:56' prior: 0!My access strategy is to delegate to the next accessor. I am not that useful all by myself, but subclasses might override certain methods to intercept access.!MADelegatorAccessor subclass: #MAChainAccessor	instanceVariableNames: 'accessor'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Accessor'!!MAChainAccessor commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am an access strategy used to chain two access strategies. To read and write a value the ==accessor== is performed on the given model and the result is passed into the ==next== accessor.!!MAChainAccessor class methodsFor: 'instance creation' stamp: 'lr 5/6/2008 18:11'!accessors: aSequenceableCollection	aSequenceableCollection isEmpty		ifTrue: [ self error: 'Unable to create accessor sequence from empty collection.' ].	aSequenceableCollection size = 1		ifTrue: [ ^ aSequenceableCollection first asAccessor ].	^ self 		on: aSequenceableCollection first asAccessor 		accessor: (self accessors: aSequenceableCollection allButFirst)! !!MAChainAccessor class methodsFor: 'instance creation' stamp: 'lr 5/6/2008 18:10'!on: anAccessor accessor: anotherAccessor	^ (self on: anAccessor) accessor: anotherAccessor! !!MAChainAccessor methodsFor: 'comparing' stamp: 'lr 5/6/2008 17:43'!= anObject	^ super = anObject and: [ self accessor = anObject accessor ]! !!MAChainAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!accessor	^ accessor! !!MAChainAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!accessor: anAccessor	accessor := anAccessor! !!MAChainAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:48'!canRead: aModel	^ (super canRead: aModel) and: [ self accessor canRead: (self next read: aModel) ]! !!MAChainAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:48'!canWrite: aModel	^ (super canRead: aModel) and: [ self accessor canWrite: (self next read: aModel) ]! !!MAChainAccessor methodsFor: 'comparing' stamp: 'lr 5/6/2008 17:43'!hash	^ super hash bitXor: self accessor hash! !!MAChainAccessor methodsFor: 'copying' stamp: 'lr 5/6/2008 17:44'!postCopy	super postCopy.	accessor := accessor copy! !!MAChainAccessor methodsFor: 'model' stamp: 'lr 5/6/2008 17:49'!read: aModel	^ self accessor read: (super read: aModel)! !!MAChainAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' on: ';		store: self next;		nextPutAll: ' accessor: ';		store: self accessor;		nextPut: $)! !!MAChainAccessor methodsFor: 'model' stamp: 'lr 5/6/2008 17:49'!write: anObject to: aModel	self accessor write: anObject to: (super read: aModel)! !!MADelegatorAccessor class methodsFor: 'testing' stamp: 'lr 2/14/2008 09:45'!isAbstract	^ false! !!MADelegatorAccessor class methodsFor: 'instance creation' stamp: 'lr 2/14/2008 09:45'!on: anAccessor	^ self new next: anAccessor! !!MADelegatorAccessor methodsFor: 'comparing' stamp: 'lr 2/14/2008 09:53'!= anObject	^ super = anObject and: [ self next = anObject next ]! !!MADelegatorAccessor methodsFor: 'testing' stamp: 'lr 2/14/2008 09:52'!canRead: aModel	^ self next canRead: aModel! !!MADelegatorAccessor methodsFor: 'testing' stamp: 'lr 2/14/2008 09:52'!canWrite: aModel	^ self next canWrite: aModel! !!MADelegatorAccessor methodsFor: 'comparing' stamp: 'lr 2/14/2008 09:54'!hash	^  super hash bitXor: self next hash! !!MADelegatorAccessor methodsFor: 'accessing' stamp: 'lr 2/14/2008 09:44'!next	^ next! !!MADelegatorAccessor methodsFor: 'accessing' stamp: 'kph 6/12/2008 01:42'!next: anAccessor 	next := anAccessor asAccessor! !!MADelegatorAccessor methodsFor: 'copying' stamp: 'lr 5/6/2008 17:44'!postCopy	super postCopy.	next := next copy! !!MADelegatorAccessor methodsFor: 'model' stamp: 'lr 2/14/2008 09:53'!read: aModel	^ self next read: aModel! !!MADelegatorAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' on: ';		store: self next;		nextPut: $)! !!MADelegatorAccessor methodsFor: 'model' stamp: 'lr 2/14/2008 09:53'!write: anObject to: aModel	self next write: anObject to: aModel! !MAAccessor subclass: #MADictionaryAccessor	instanceVariableNames: 'key'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Accessor'!!MADictionaryAccessor commentStamp: 'lr 4/10/2007 21:07' prior: 0!I am an access strategy to be used on dictionaries. I use my ==key== to read from and write to indexed collections.!!MADictionaryAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MADictionaryAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!key: aSymbol	^ self new		key: aSymbol;		yourself! !!MADictionaryAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self key = anObject key ]! !!MADictionaryAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:50'!canRead: aModel	^ true! !!MADictionaryAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:50'!canWrite: aModel	^ true! !!MADictionaryAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self key hash! !!MADictionaryAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!key	^ key! !!MADictionaryAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!key: aKey	key := aKey! !!MADictionaryAccessor methodsFor: 'model' stamp: 'lr 10/25/2007 23:53'!read: aModel	^ aModel at: self key ifAbsent: [ nil ]! !!MADictionaryAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' key: ';		store: self key;		nextPut: $)! !!MADictionaryAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!write: anObject to: aModel	aModel at: self key put: anObject! !MAAccessor subclass: #MAIdentityAccessor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Accessor'!!MAIdentityAccessor commentStamp: 'lr 2/12/2006 20:09' prior: 0!I am a read-only access strategy and I answer the model itself when being read.!!MAIdentityAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAIdentityAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:50'!canRead: aModel	^ true! !!MAIdentityAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!read: aModel	^ aModel! !!MAIdentityAccessor methodsFor: 'model' stamp: 'jf 9/30/2009 01:10'!write: anObject to: aModel 	MAWriteError signal: 'Not supposed to write to ' , aModel greaseString , '.'! !MAAccessor subclass: #MANullAccessor	instanceVariableNames: 'uuid'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Accessor'!!MANullAccessor commentStamp: 'lr 5/29/2006 09:21' prior: 0!I am a null access strategy and I should be neither read nor written. I am still comparable to other strategies by holding onto a unique-identifier.!!MANullAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MANullAccessor class methodsFor: 'instance creation' stamp: 'jf 10/28/2009 15:23'!new	| random uuid |	random := GRPlatform current newRandom.	uuid := Array new: 16.	1 to: 16 do: [ :i | uuid at: i put: (random nextInt: 256) -1 ].	^ self uuid: uuid! !!MANullAccessor class methodsFor: 'instance creation' stamp: 'jf 10/18/2009 13:22'!uuid: anObject	^ self basicNew		uuid: anObject;		yourself! !!MANullAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self uuid = anObject uuid ]! !!MANullAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self uuid hash! !!MANullAccessor methodsFor: 'model' stamp: 'lr 4/10/2008 14:11'!read: aModel 	MAReadError signal: 'This message is not appropriate for this object'! !!MANullAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' uuid: ';		store: self uuid;		nextPut: $)! !!MANullAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uuid	^ uuid! !!MANullAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uuid: anObject	uuid := anObject! !!MANullAccessor methodsFor: 'model' stamp: 'lr 4/10/2008 14:11'!write: anObject to: aModel 	MAWriteError signal: 'This message is not appropriate for this object'! !MAAccessor subclass: #MAPluggableAccessor	instanceVariableNames: 'readBlock writeBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Accessor'!!MAPluggableAccessor commentStamp: 'lr 2/12/2006 20:04' prior: 0!I am an access strategy defined by two block-closures. The read-block expects the model as its first argument and is used to retrieve a value. The write-block expects the model as its first and the value as its second argument and is used to write a value to the model.!!MAPluggableAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAPluggableAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!read: aReadBlock write: aWriteBlock	^ self new		readBlock: aReadBlock;		writeBlock: aWriteBlock;		yourself! !!MAPluggableAccessor methodsFor: 'comparing' stamp: 'lr 2/16/2007 08:48'!= anObject	^ super = anObject		and: [ self readBlock = anObject readBlock		and: [ self writeBlock = anObject writeBlock ] ]! !!MAPluggableAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:42'!canRead: aModel	^ self readBlock notNil! !!MAPluggableAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:43'!canWrite: aModel	^ self writeBlock notNil! !!MAPluggableAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!hash	^ super hash bitXor: (self readBlock hash bitXor: self writeBlock hash)! !!MAPluggableAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:31'!read: aModel	^ self readBlock value: aModel! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!readBlock	^ readBlock! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!readBlock: aBlock	readBlock := aBlock! !!MAPluggableAccessor methodsFor: 'printing' stamp: 'jf 9/30/2009 01:10'!storeBlock: aBlock on: aStream 	aStream nextPutAll: aBlock decompile greaseString allButFirst allButLast! !!MAPluggableAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' read: '.	self storeBlock: self readBlock on: aStream.	aStream nextPutAll: ' write: '.	self storeBlock: self writeBlock on: aStream.	aStream nextPut: $)! !!MAPluggableAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:31'!write: anObject to: aModel	self writeBlock value: aModel value: anObject! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!writeBlock	^ writeBlock! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!writeBlock: aBlock	writeBlock := aBlock! !MAAccessor subclass: #MASelectorAccessor	instanceVariableNames: 'readSelector writeSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Accessor'!!MASelectorAccessor commentStamp: 'lr 6/2/2006 10:03' prior: 0!I am the most common access strategy defined by a read- and a write-selector. I am mostly used together with standard getters and setters as usually defined by the accessing protocol. If there is only a read-selector specified, the write selector will be deduced automatically by adding a colon to the read-selector.!!MASelectorAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!read: aReadSelector write: aWriteSelector	^ self new		readSelector: aReadSelector;		writeSelector: aWriteSelector;		yourself! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!selector: aSelector	^ self new		selector: aSelector;		yourself! !!MASelectorAccessor methodsFor: 'comparing' stamp: 'lr 2/16/2007 08:49'!= anObject	^ super = anObject		and: [ self readSelector = anObject readSelector		and: [ self writeSelector = anObject writeSelector ] ]! !!MASelectorAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:51'!canRead: aModel	^ self readSelector notNil and: [ aModel respondsTo: self readSelector ]! !!MASelectorAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:51'!canWrite: aModel	^ self writeSelector notNil and: [ aModel respondsTo: self writeSelector ]! !!MASelectorAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^  super hash bitXor: (self readSelector hash bitXor: self writeSelector hash)! !!MASelectorAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!read: aModel	^ aModel perform: self readSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!readSelector	^ readSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!readSelector: aSelector	readSelector := aSelector! !!MASelectorAccessor methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!selector	^ self readSelector! !!MASelectorAccessor methodsFor: 'accessing-dynamic' stamp: 'jf 9/30/2009 01:10'!selector: aSelector 	self readSelector: aSelector asSymbol.	self writeSelector: (aSelector greaseString copyWith: $:) asSymbol! !!MASelectorAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:15'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' read: ';		store: self readSelector;		nextPutAll: ' write: ';		store: self writeSelector;		nextPut: $)! !!MASelectorAccessor methodsFor: 'model' stamp: 'fbs 6/2/2011 17:59'!write: anObject to: aModel	^ aModel perform: self writeSelector with: anObject! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!writeSelector	^ writeSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!writeSelector: aSelector	writeSelector := aSelector! !MAAccessor subclass: #MAVariableAccessor	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Accessor'!!MAVariableAccessor commentStamp: 'lr 5/27/2006 17:20' prior: 0!I am an access strategy that directly reads from and writes to instance variables. I strongly violate encapsulation and most of the time I should be replaced by an instance of *MASelectorAccessor*.!!MAVariableAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAVariableAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!name: aString	^ self new		name: aString;		yourself! !!MAVariableAccessor methodsFor: 'comparing' stamp: 'lr 5/6/2008 17:51'!= anObject	^ super = anObject and: [ self name = anObject name ]! !!MAVariableAccessor methodsFor: 'testing' stamp: 'AvO 3/12/2012 15:29'!canRead: aModel	^ aModel class allInstVarNames includes: self name! !!MAVariableAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:52'!canWrite: aModel	^ self canRead: aModel! !!MAVariableAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self name hash! !!MAVariableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!name	^ name! !!MAVariableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!name: aString	name := aString! !!MAVariableAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!read: aModel	^ aModel instVarNamed: self name! !!MAVariableAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:15'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' name: ';		store: self name;		nextPut: $)! !!MAVariableAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!write: anObject to: aModel	aModel instVarNamed: self name put: anObject! !MAObject subclass: #MACondition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Utility'!!MACondition class methodsFor: 'testing' stamp: 'lr 2/5/2009 21:05'!isAbstract	^ self name = #MACondition! !!MACondition class methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:30'!receiver: anObject selector: aSelector	^ self receiver: anObject selector: aSelector arguments: #(nil) index: 1! !!MACondition class methodsFor: 'instance creation' stamp: 'lr 2/5/2009 21:30'!receiver: anObject selector: aSelector arguments: anArray index: anInteger	(aSelector numArgs = anArray size)		ifFalse: [ self error: 'Invalid number of arguments.' ].	(anInteger between: 0 and: anArray size)		ifFalse: [ self error: 'Index out of bounds.' ].	^ MAPluggableCondition new 		initializeReceiver: anObject		selector: aSelector		arguments: anArray		index: anInteger! !!MACondition class methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:30'!selector: aSelector	^ self receiver: nil selector: aSelector arguments: #() index: 0! !!MACondition class methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:30'!selector: aSelector argument: anObject	^ self receiver: nil selector: aSelector arguments: (Array with: anObject) index: 0! !!MACondition methodsFor: 'operators' stamp: 'lr 2/5/2009 20:40'!& aCondition 	^ MAConjunctiveCondition new & self & aCondition! !!MACondition methodsFor: 'operators' stamp: 'lr 2/5/2009 21:56'!not	^ MANegationCondition with: self! !!MACondition methodsFor: 'accessing' stamp: 'lr 2/5/2009 20:56'!numArgs	^ 1! !!MACondition methodsFor: 'evaluating' stamp: 'lr 2/5/2009 20:43'!value: anObject	self subclassResponsibility! !!MACondition methodsFor: 'operators' stamp: 'lr 2/5/2009 20:40'!| aCondition 	^ (self not & aCondition not) not! !MACondition subclass: #MAConjunctiveCondition	instanceVariableNames: 'conditions'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Utility'!!MAConjunctiveCondition methodsFor: 'operators' stamp: 'lr 2/5/2009 20:42'!& aCondition	conditions := conditions copyWith: aCondition! !!MAConjunctiveCondition methodsFor: 'initialization' stamp: 'lr 2/5/2009 20:42'!initialize	conditions := #()! !!MAConjunctiveCondition methodsFor: 'evaluating' stamp: 'lr 2/5/2009 20:44'!value: anObject	^ conditions allSatisfy: [ :each | each value: anObject ]! !MACondition subclass: #MANegationCondition	instanceVariableNames: 'condition'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Utility'!!MANegationCondition class methodsFor: 'instance creation' stamp: 'lr 2/5/2009 20:45'!with: aCondition	^ self new initializeWith: aCondition! !!MANegationCondition methodsFor: 'initialization' stamp: 'lr 2/5/2009 21:55'!initializeWith: aCondition	condition := aCondition! !!MANegationCondition methodsFor: 'evaluating' stamp: 'lr 2/5/2009 20:44'!value: anObject	^ (condition value: anObject) not! !MACondition subclass: #MAPluggableCondition	instanceVariableNames: 'receiver selector arguments index'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Utility'!!MAPluggableCondition methodsFor: 'initialization' stamp: 'lr 2/5/2009 21:30'!initializeReceiver: anObject selector: aSelector arguments: anArray index: anInteger	receiver := anObject.	selector := aSelector.	arguments := anArray.	index := anInteger! !!MAPluggableCondition methodsFor: 'evaluating' stamp: 'lr 2/5/2009 21:31'!value: anObject	| actualReceiver actualArguments |	actualReceiver := index = 0		ifFalse: [ receiver ]		ifTrue: [ anObject ].	actualArguments := index > 0		ifFalse: [ arguments ]		ifTrue: [			arguments copy 				at: index put: anObject;				yourself ].	^ actualReceiver		perform: selector		withArguments: actualArguments! !MAObject subclass: #MADescription	instanceVariableNames: 'accessor'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MADescription commentStamp: 'lr 2/5/2009 12:42' prior: 0!I am the root of the description hierarchy in Magritte and I provide most of the basic properties available to all descriptions. If you would like to annotate your model with a description have a look at the different subclasses of myself.!!ExampleIf your model has an instance variable called ==title== that should be used to store the title of the object, you could add the following description to your class:=Document class>>descriptionTitle=	^ MAStringDescription new=		autoAccessor: #title;=		label: 'Title';=		priority: 20;=		beRequired;=		yourself.The selector ==#title== is the name of the accessor method used by Magritte to retrieve the value from the model. In the above case Magritte creates the accessor method and the instance variable automatically, if necessary. The label is used to give the field a name and will be printed next to the input box if a visual GUI is created from this description.The write-accessor is automatically deduced by adding a colon to the read-selector, in this example ==#title:==. You can specify your own accessor strategy using one of the subclasses of ==*MAAccessor*==. If you have multiple description within the same object, the ==#priority:== field is used to order them. Assign a low priority to have descriptions traversed first.!MADescription subclass: #MAContainer	instanceVariableNames: 'children'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAContainer commentStamp: 'lr 4/10/2007 21:06' prior: 0!I am a container holding a collection of descriptions, all instances of subclasses of *MAElementDescription*. I keep my children within an ==OrderedCollection==, but I don't sort them according to their priority.I fully support the collection protocol: descriptions can be added and removed. Moreover I implement most enumeration methods, so that users are able to iterate (==do:==), filter (==select:==, ==reject:==), transform (==collect:==), extract (==detect:==, ==detect:ifNone:==), and test (==allSatisfy:==, ==anySatisfy:==, ==noneSatisfy:==) my elements.!!MAContainer class methodsFor: 'accessing-defaults' stamp: 'lr 4/10/2008 13:55'!defaultAccessor	^ MAIdentityAccessor new! !!MAContainer class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultCollection	^ OrderedCollection new! !!MAContainer class methodsFor: 'accessing-description' stamp: 'jf 9/17/2009 15:42'!descriptionChildren	^ MAToManyRelationDescription new		accessor: (MASelectorAccessor read: #children write: #setChildren:);		classes: [ MAElementDescription withAllConcreteClasses ] magritteDynamicObject;		default: self defaultCollection;		label: 'Elements';		priority: 400;		beOrdered;		yourself! !!MAContainer class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:32'!descriptionDefault	^ nil! !!MAContainer class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAContainer class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!with: aDescription	^ self new		add: aDescription;		yourself! !!MAContainer class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!withAll: aCollection	^ self new		addAll: aCollection;		yourself! !!MAContainer methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self children = anObject children ]! !!MAContainer methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitContainer: self! !!MAContainer methodsFor: 'adding' stamp: 'lr 3/9/2006 11:32'!add: aDescription	self children add: aDescription! !!MAContainer methodsFor: 'adding' stamp: 'lr 3/9/2006 11:32'!addAll: aCollection	self children addAll: aCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:09'!allSatisfy: aBlock	^ self children allSatisfy: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:09'!anySatisfy: aBlock	^ self children anySatisfy: aBlock! !!MAContainer methodsFor: 'converting' stamp: 'lr 3/9/2006 11:32'!asContainer	^ self! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!at: anIndex	^ self children at: anIndex! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!at: anIndex ifAbsent: aBlock	^ self children at: anIndex ifAbsent: aBlock! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!children	^ children! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!collect: aBlock	^ self copy		setChildren: (self children collect: aBlock);		yourself! !!MAContainer methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyEmpty	^ self copy		setChildren: self class defaultCollection;		yourself! !!MAContainer methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyFrom: aStartIndex to: anEndIndex	^ self copy		setChildren: (self children			copyFrom: aStartIndex			to: anEndIndex);		yourself! !!MAContainer methodsFor: 'copying' stamp: 'lr 2/12/2007 19:06'!copyWithout: anObject	^self reject: [:each | each = anObject]! !!MAContainer methodsFor: 'copying' stamp: 'lr 2/12/2007 19:06'!copyWithoutAll: aCollection	^self reject: [:each | aCollection includes: each]! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!detect: aBlock	^ self children detect: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!detect: aBlock ifNone: anExceptionBlock	^ self children detect: aBlock ifNone: anExceptionBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!do: aBlock	self children do: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!do: aBlock separatedBy: aSeparatorBlock	self children do: aBlock separatedBy: aSeparatorBlock! !!MAContainer methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!errorNotFound: aDescription	self error: aDescription class label , ' not found.'! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!hasChildren	^ self notEmpty! !!MAContainer methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self children hash! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!includes: aDescription	^ self children includes: aDescription! !!MAContainer methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!initialize	super initialize.	self setChildren: self class defaultCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!inject: anObject into: aBlock	^ self children inject: anObject into: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!intersection: aCollection	^ self copy		setChildren: (self children intersection: aCollection);		yourself! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isContainer	^ true! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isEmpty	^ self children isEmpty! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 4/10/2008 14:05'!keysAndValuesDo: aBlock	self children keysAndValuesDo: aBlock! !!MAContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveDown: aDescription	self children moveDown: aDescription! !!MAContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveUp: aDescription	self children moveUp: aDescription! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:08'!noneSatisfy: aBlock	^ self children noneSatisfy: aBlock! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!notEmpty	^ self children notEmpty! !!MAContainer methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!postCopy	super postCopy.	self setChildren: self children copy! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!reject: aBlock	^ self copy		setChildren: (self children reject: aBlock);		yourself! !!MAContainer methodsFor: 'removing' stamp: 'lr 3/9/2006 11:32'!remove: aDescription	self children remove: aDescription ifAbsent: [ self errorNotFound: aDescription ]! !!MAContainer methodsFor: 'removing' stamp: 'lr 3/9/2006 11:32'!removeAll	self setChildren: self class defaultCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!select: aBlock	^ self copy		setChildren: (self children select: aBlock);		yourself! !!MAContainer methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setChildren: aCollection	children := aCollection! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!size	^ self children size! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:09'!union: aContainer	^ self copy		addAll: (aContainer reject: [ :each | self includes: each ]);		yourself! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!with: aCollection do: aBlock	self children with: aCollection do: aBlock! !MAContainer subclass: #MAPriorityContainer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAPriorityContainer commentStamp: 'lr 2/12/2006 19:34' prior: 0!I am a container holding a collection of descriptions and I keep them sorted according to their priority.!!MAPriorityContainer class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultCollection	^ SortedCollection new! !!MAPriorityContainer methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitPriorityContainer: self! !!MAPriorityContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveDown: aDescription	self shouldNotImplement! !!MAPriorityContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveUp: aDescription	self shouldNotImplement! !!MAPriorityContainer methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!resort	self setChildren: self children copy! !!MAPriorityContainer methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setChildren: aCollection	super setChildren: aCollection asSortedCollection! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultAccessor	^ MANullAccessor new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultComment	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultConditions	^ Array new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultDefault	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 10/27/2007 12:01'!defaultGroup	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:22'!defaultKind	^ Object! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 10/27/2007 12:01'!defaultLabel	^ String new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultPersistent	^ true! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultPriority	^ 0! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultReadonly	^ false! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultRequired	^ false! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultStringReader	^ MAStringReader! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultStringWriter	^ MAStringWriter! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultUndefined	^ String new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 2/16/2007 08:39'!defaultValidator	^ MAValidatorVisitor! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultVisible	^ true! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionComment	^ MAMemoDescription new		accessor: #comment;		label: 'Comment';		priority: 110;		default: self defaultComment;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionDefault	^ self isAbstract ifFalse: 		[ self new			accessor: #default;			label: 'Default';			priority: 130;			default: self defaultDefault;			yourself ]! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionGroup	^ MAStringDescription new		accessor: #group;		default: self defaultGroup;		label: 'Group';		priority: 105;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionLabel	^ MAStringDescription new		accessor: #label;		label: 'Label';		priority: 100;		default: self defaultLabel;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionName	^ MAStringDescription new		accessor: #name;		label: 'Kind';		priority: 0;		beReadonly;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionPriority	^ MANumberDescription new		accessor: #priority;		label: 'Priority';		priority: 130;		default: self defaultPriority;		beRequired;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionReadonly	^ MABooleanDescription new		accessor: #readonly;		label: 'Readonly';		priority: 200;		default: self defaultReadonly;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionRequired	^ MABooleanDescription new		accessor: #required;		label: 'Required';		priority: 220;		default: self defaultRequired;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'jf 9/17/2009 15:42'!descriptionStringReader	^ MASingleOptionDescription new		accessor: #stringReader;		label: 'String Reader';		priority: 300;		default: self defaultStringReader;		options: [ self defaultStringReader withAllSubclasses ] magritteDynamicObject;		reference: MAClassDescription new;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'jf 9/17/2009 15:42'!descriptionStringWriter	^ MASingleOptionDescription new		accessor: #stringWriter;		label: 'String Writer';		priority: 310;		default: self defaultStringWriter;		options: [ self defaultStringWriter withAllSubclasses ] magritteDynamicObject;		reference: MAClassDescription new;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionUndefined	^ MAStringDescription new		accessor: #undefined;		label: 'Undefined String';		priority: 140;		default: self defaultUndefined;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'jf 9/17/2009 15:42'!descriptionValidator	^ MASingleOptionDescription new		accessor: #validator;		label: 'Validator';		priority: 250;		default: self defaultValidator;		options: [ self defaultValidator withAllSubclasses ] magritteDynamicObject;		reference: MAClassDescription new;		yourself! !!MADescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionVisible	^ MABooleanDescription new		accessor: #visible;		label: 'Visible';		priority: 210;		default: self defaultVisible;		yourself! !!MADescription class methodsFor: 'accessing-examples' stamp: 'lr 11/1/2009 08:36'!grouping	^ MADescriptionHolder groupOf: self! !!MADescription methodsFor: 'operators' stamp: 'lr 4/10/2007 21:32'!, aDescription	"Concatenate the receiver and ==aDescription== to one composed description. Answer a description container containing both descriptions."	^ self asContainer copy		addAll: aDescription asContainer;		yourself! !!MADescription methodsFor: 'operators' stamp: 'lr 4/10/2007 21:33'!<= anObject	"Answer whether the receiver should precede ==anObject== in a priority container."	^ self priority <= anObject priority! !!MADescription methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self accessor = anObject accessor ]! !!MADescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitDescription: self! !!MADescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!accessor	"Answer the access-strategy of the model-value described by the receiver."	^ accessor ifNil: [ accessor := self class defaultAccessor ]! !!MADescription methodsFor: 'accessing' stamp: 'lr 4/10/2008 13:34'!accessor: anObject	accessor := anObject asAccessor! !!MADescription methodsFor: 'validation' stamp: 'jf 9/30/2009 01:10'!addCondition: aCondition 	self 		addCondition: aCondition		labelled: aCondition greaseString! !!MADescription methodsFor: 'validation' stamp: 'lr 2/5/2009 12:25'!addCondition: aCondition labelled: aString	"Add ==aCondition== as an additional validation condition to the receiver and give it the label ==aString==. The first argument is either a block-context or any other object that responds to ==#value:== with ==true== or ==false==."	self conditions: (self conditions		copyWith: (Association			key: aCondition			value: aString))! !!MADescription methodsFor: 'converting' stamp: 'lr 3/9/2006 11:32'!asContainer	"Answer a description container of the receiver."	self subclassResponsibility! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beHidden	self visible: false! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beOptional	self required: false! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beReadonly	self readonly: true! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beRequired	self required: true! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beVisible	self visible: true! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beWriteable	self readonly: false! !!MADescription methodsFor: 'accessors' stamp: 'kph 6/9/2008 17:50'!chainAccessor: anArray	"Uses ==anArray== of selectors to read from the model."	self accessor: (MAChainAccessor accessors: anArray)! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!comment	"Answer a comment or help-text giving a hint what this description is used for. GUIs that are built from this description might display it as a tool-tip."	^ self propertyAt: #comment ifAbsent: [ self class defaultComment ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!comment: aString	self propertyAt: #comment put: aString! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 2/5/2009 12:24'!conditions	"Answer a collection of additional conditions that need to be fulfilled so that the described model is valid. Internally the collection associates conditions with an error string."	^ self propertyAt: #conditions ifAbsent: [ self class defaultConditions ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!conditions: anArray	self propertyAt: #conditions put: anArray! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 11/14/2006 17:42'!conflictErrorMessage	^ self propertyAt: #conflictErrorMessage ifAbsent: [ 'Input is conflicting with concurrent modification' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 3/25/2009 19:29'!conflictErrorMessage: aString	self propertyAt: #conflictErrorMessage put: aString! !!MADescription methodsFor: 'accessing' stamp: 'lr 12/7/2006 15:44'!default	^ nil! !!MADescription methodsFor: 'accessing' stamp: 'lr 12/7/2006 15:44'!default: anObject! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:33'!fromString: aString	"Answer an object being parsed from ==aString==."	^ self fromString: aString reader: self stringReader! !!MADescription methodsFor: 'strings' stamp: 'lr 9/12/2007 17:26'!fromString: aString reader: aParser	"Answer an object being parsed from ==aString== using ==aParser==."	^ aParser read: aString readStream description: self! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:33'!fromStringCollection: aCollection	"Answer a collection of objects being parsed from ==aCollection== of strings."	^ self fromStringCollection: aCollection reader: self stringReader! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:34'!fromStringCollection: aCollection reader: aParser	"Answer a collection of objects being parsed from ==aCollection== of strings using ==aParser==."	^ aCollection collect: [ :each | self fromString: each reader: aParser ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 2/8/2009 19:20'!group	"Answer the group of the receiving description. The group is a string used to categorize and group descriptions. Certain display interpreters with be able to use this information to improve the usability."	^ self propertyAt: #group ifAbsent: [ self class defaultGroup ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:30'!group: aString	"Answer the group of the receiving description. The group is a string used to categorize and group descriptions. Certain display interpreters with be able to use this information to improve the usability."	self propertyAt: #group put: aString! !!MADescription methodsFor: 'testing' stamp: 'lr 4/10/2007 21:34'!hasChildren	"Answer ==true== if the receiver has any child-descriptions. A description container usually has children."	^ false! !!MADescription methodsFor: 'testing' stamp: 'lr 8/13/2008 23:48'!hasComment	"Answer ==true== if the the receiver has got a non empty comment."	^ self comment notNil and: [ self comment isEmpty not ]! !!MADescription methodsFor: 'testing' stamp: 'lr 8/13/2008 23:48'!hasLabel	"Answer ==true== if the the receiver has got a non empty label."	^ self label notNil and: [ self label isEmpty not ]! !!MADescription methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self accessor hash! !!MADescription methodsFor: 'testing' stamp: 'lr 4/10/2007 21:34'!isContainer	"Answer ==true== if the receiver is a description container."	^ false! !!MADescription methodsFor: 'testing' stamp: 'lr 4/10/2007 21:34'!isDescription	"Answer ==true== if the receiver is a description."	^ true! !!MADescription methodsFor: 'testing' stamp: 'lr 7/25/2008 17:33'!isGrouped	^ false! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:18'!isReadonly	^ self readonly! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:18'!isRequired	^ self required! !!MADescription methodsFor: 'validation' stamp: 'lr 4/10/2007 21:34'!isSatisfiedBy: anObject	"Answer ==true== if ==anObject== is a valid instance of the receiver's description."	[ self validate: anObject ]		on: MAValidationError		do: [ :err | ^ false ].	^ true! !!MADescription methodsFor: 'testing' stamp: 'lr 8/18/2007 11:14'!isSortable	"Answer ==true== if the described object can be trivially sorted, e.g. it answers to #<=."	^ false! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:18'!isVisible	^ self visible! !!MADescription methodsFor: 'accessing' stamp: 'lr 9/3/2009 17:22'!kind	"Answer the base-class (type) the receiver is describing. The default implementation answers the most generic class: Object, the root of the Smalltalk class hierarchy. Subclasses might refine this choice."	^ self propertyAt: #kind ifAbsent: [ self class defaultKind ]! !!MADescription methodsFor: 'accessing' stamp: 'lr 9/3/2009 17:22'!kind: aClass	self propertyAt: #kind put: aClass! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 11/14/2006 17:42'!kindErrorMessage	^ self propertyAt: #kindErrorMessage ifAbsent: [ 'Invalid input given' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 3/25/2009 19:29'!kindErrorMessage: aString	self propertyAt: #kindErrorMessage put: aString! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!label	"Answer the label of the receiving description. The label is mostly used as an identifier that is printed next to the input field when building a GUI from the receiver."	^ self propertyAt: #label ifAbsent: [ self class defaultLabel ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!label: aString	self propertyAt: #label put: aString! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 11/14/2006 17:42'!multipleErrorsMessage	^ self propertyAt: #multipleErrorsMessage ifAbsent: [ 'Multiple errors' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 3/25/2009 19:29'!multipleErrorsMessage: aString	self propertyAt: #multipleErrorsMessage put: aString! !!MADescription methodsFor: 'accessing-configuration' stamp: 'lr 4/10/2006 10:31'!name	"Answer the name of the description, a human-readable string describing the type."	^ self class label! !!MADescription methodsFor: 'copying' stamp: 'lr 3/26/2007 11:45'!postCopy	super postCopy.	accessor := accessor copy! !!MADescription methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' label: '; print: self label.	aStream nextPutAll: ' comment: '; print: self comment! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 5/29/2006 09:19'!priority	"Answer a number that is the priority of the receiving description. Priorities are used to give descriptions an explicit order by sorting them according to this number."	^ self propertyAt: #priority ifAbsent: [ self class defaultPriority ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!priority: aNumber	self propertyAt: #priority put: aNumber! !!MADescription methodsFor: 'accessors' stamp: 'lr 7/8/2008 08:31'!propertyAccessor: aSelector	"Uses ==aSelector== to read from the property dictionary of the model."	self accessor: ((MAChainAccessor on: #properties) 		accessor: (MADictionaryAccessor key: aSelector))! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 4/10/2007 21:35'!readonly	"Answer ==true== if the model described by the receiver is read-only."	^ self propertyAt: #readonly ifAbsent: [ self class defaultReadonly ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!readonly: aBoolean	self propertyAt: #readonly put: aBoolean! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 4/10/2007 21:35'!required	"Answer ==true== if the model described by the receiver is required, this is it cannot be ==nil==."	^ self propertyAt: #required ifAbsent: [ self class defaultRequired ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!required: aBoolean	self propertyAt: #required put: aBoolean! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 11/14/2006 17:44'!requiredErrorMessage	^ self propertyAt: #requiredErrorMessage ifAbsent: [ 'Input is required but no input given' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 3/25/2009 19:30'!requiredErrorMessage: aString	self propertyAt: #requiredErrorMessage put: aString! !!MADescription methodsFor: 'accessors' stamp: 'lr 9/12/2007 17:26'!selectorAccessor: aSelector	"Uses ==aSelector== to read from the model."	self accessor: (MASelectorAccessor selector: aSelector)! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 6/2/2006 09:07'!stringReader	"Answer a Visitor that can be used to parse the model described by the receiver from a string."	^ self propertyAt: #stringReader ifAbsent: [ self class defaultStringReader ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 3/9/2006 11:32'!stringReader: aClass	self propertyAt: #stringReader put: aClass! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 6/2/2006 09:10'!stringWriter	"Answer a Visitor that can be used to convert the model described by the receiver to a string."	^ self propertyAt: #stringWriter ifAbsent: [ self class defaultStringWriter ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 3/9/2006 11:32'!stringWriter: aClass	self propertyAt: #stringWriter put: aClass! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:35'!toString: anObject	"Answer a string being formatted from ==anObject==."	^ self toString: anObject writer: self stringWriter! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:35'!toString: anObject writer: aFormatter	"Answer a string being formatted from ==anObject== using ==aFormatter==."	^ aFormatter write: anObject description: self! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:36'!toStringCollection: aCollection	"Answer a collection of strings being formatted from ==aCollection==."	^ self toStringCollection: aCollection writer: self stringWriter! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:36'!toStringCollection: aCollection writer: aFormatter	"Answer a collection of strings being formatted from ==aCollection== using ==aFormatter==."	^ aCollection collect: [ :each | self toString: each writer: aFormatter ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 4/10/2007 21:37'!undefined	"Answer a string that is printed whenever the model described by the receiver is ==nil==."	^ (self propertyAt: #undefined ifAbsent: [ self class defaultUndefined ])		ifNil: [ self class defaultUndefined ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 3/9/2006 11:32'!undefined: aString	self propertyAt: #undefined put: aString! !!MADescription methodsFor: 'validation' stamp: 'lr 9/12/2007 17:26'!validate: anObject	"Validate ==anObject== in the context of the describing-receiver, raises an error in case of a problem. If ==anObject== is ==nil== and not required, most tests will be skipped. Do not override this message, instead have a look at ==#validateSpecific:== what is usually a better place to define the behaviour your description requires."	self validator on: anObject description: self! !!MADescription methodsFor: 'validation-private' stamp: 'lr 4/10/2007 21:38'!validateConditions: anObject	"Validate ==anObject== to satisfy all its custom conditions."	self conditions do: [ :each |		(each key value: anObject)			ifFalse: [ MAConditionError description: self signal: each value ] ]! !!MADescription methodsFor: 'validation-private' stamp: 'lr 4/10/2007 21:39'!validateKind: anObject	"Validate ==anObject== to be of the right kind."	(anObject isKindOf: self kind)		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MADescription methodsFor: 'validation-private' stamp: 'lr 4/10/2007 21:39'!validateRequired: anObject	"Validate ==anObject== not to be ==nil== if it is required."	(self isRequired and: [ anObject isNil ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !!MADescription methodsFor: 'validation-private' stamp: 'lr 4/10/2007 21:39'!validateSpecific: anObject	"Validate ==anObject== to satisfy its descriptions specific validation rules. Subclasses mostly want to override this method."! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 2/16/2007 08:39'!validator	"Answer a Visitor that can be used to validate the model described by the receiver."	^ self propertyAt: #validator ifAbsent: [ self class defaultValidator ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 2/16/2007 08:39'!validator: aClass	self propertyAt: #validator put: aClass! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 4/10/2007 21:39'!visible	"Answer ==true== if the model described by the receiver is visible, as an opposite to hidden."	^ self propertyAt: #visible ifAbsent: [ self class defaultVisible ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!visible: aBoolean	self propertyAt: #visible put: aBoolean! !MADescription subclass: #MAElementDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAElementDescription commentStamp: '<historical>' prior: 0!I am an abstract description for all basic description types.!MAElementDescription subclass: #MABooleanDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MABooleanDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of the Boolean values ==true== and ==false==. My visual representation could be a check-box.!!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultFalseString	^ self defaultFalseStrings first! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultFalseStrings	^ #( 'false' 'f' 'no' 'n' '0' 'off' )! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Boolean! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultTrueString	^ self defaultTrueStrings first! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultTrueStrings	^ #( 'true' 't' 'yes' 'y' '1' 'on' )! !!MABooleanDescription class methodsFor: 'accessing-descriptions' stamp: 'lr 4/10/2008 14:17'!descriptionFalseString	^ MAStringDescription new		accessor: #falseString;		default: self defaultFalseString;		label: 'False String';		priority: 410;		yourself! !!MABooleanDescription class methodsFor: 'accessing-descriptions' stamp: 'lr 3/9/2006 11:32'!descriptionRequired	^ nil! !!MABooleanDescription class methodsFor: 'accessing-descriptions' stamp: 'lr 4/10/2008 14:17'!descriptionTrueString	^ MAStringDescription new		accessor: #trueString;		default: self defaultTrueString;		label: 'True String';		priority: 400;		yourself! !!MABooleanDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MABooleanDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Boolean'! !!MABooleanDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:31'!acceptMagritte: aVisitor	aVisitor visitBooleanDescription: self! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!allOptions	^ self options! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!allOptionsWith: anObject	^ self options! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:31'!falseString	^ self propertyAt: #falseString ifAbsent: [ self class defaultFalseString ]! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:30'!falseString: aString	self propertyAt: #falseString put: aString! !!MABooleanDescription methodsFor: 'accessing-readonly' stamp: 'lr 3/9/2006 11:31'!falseStrings	^ self class defaultFalseStrings! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!isExtensible	^ false! !!MABooleanDescription methodsFor: 'private' stamp: 'lr 4/21/2007 17:45'!labelForOption: anObject	anObject == true		ifTrue: [ ^ self trueString ].	anObject == false		ifTrue: [ ^ self falseString ].	^ self undefined! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!options	^ Array with: false with: true! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!reference	^ self! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:31'!trueString	^ self propertyAt: #trueString ifAbsent: [ self class defaultTrueString ]! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:30'!trueString: aString	self propertyAt: #trueString put: aString! !!MABooleanDescription methodsFor: 'accessing-readonly' stamp: 'lr 3/9/2006 11:31'!trueStrings	^ self class defaultTrueStrings! !MAElementDescription subclass: #MAClassDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAClassDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of Smalltalk classes, possible values can be any of ==Smalltalk allClasses==.!!MAClassDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Class! !!MAClassDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAClassDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Class'! !!MAClassDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:31'!acceptMagritte: aVisitor	aVisitor visitClassDescription: self! !MAElementDescription subclass: #MAColorDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAColorDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of colors, possible values are instances of ==Color==. My visual representation could be a color-chooser.!!MAColorDescription class methodsFor: 'accessing-defaults' stamp: 'jf 9/30/2009 00:19'!defaultKind	^ GRPlatform current magritteColorClass! !!MAColorDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAColorDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Color'! !!MAColorDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:31'!acceptMagritte: aVisitor	aVisitor visitColorDescription: self! !!MAElementDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitElementDescription: self! !!MAElementDescription methodsFor: 'converting' stamp: 'lr 3/9/2006 11:32'!asContainer	^ MAContainer with: self! !!MAElementDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!default	^ self propertyAt: #default ifAbsent: [ self class defaultDefault ]! !!MAElementDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!default: anObject	self propertyAt: #default put: anObject! !MAElementDescription subclass: #MAFileDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAFileDescription commentStamp: 'lr 5/17/2006 14:44' prior: 0!I am a description of files, their contents, filename and mime-type. Possible values include instances of *MAFileModel*. My visual representation could be a file-upload dialog.!!MAFileDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:32'!defaultKind	^ MAMemoryFileModel! !!MAFileDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAFileDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'File'! !!MAFileDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitFileDescription: self! !MAElementDescription subclass: #MAMagnitudeDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAMagnitudeDescription commentStamp: 'lr 4/10/2007 21:08' prior: 0!I am an abstract description for subclasses of ==Magnitude==. The range of accepted values can be limited using the accessors ==min:== and ==max:==.!MAMagnitudeDescription subclass: #MADateAndTimeDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MADateAndTimeDescription commentStamp: 'pmm 8/31/2009 20:11' prior: 0!I am a description of date and times, possible values are instances of ==DateAndTime==. My visual representation could be a date- and time-picker.!!MADateAndTimeDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ DateAndTime! !!MADateAndTimeDescription class methodsFor: 'testing' stamp: 'pmm 8/31/2009 20:07'!isAbstract	^ false! !!MADateAndTimeDescription class methodsFor: 'accessing' stamp: 'pmm 8/31/2009 20:13'!label	^ 'Date and Time'! !!MADateAndTimeDescription methodsFor: 'visiting' stamp: 'pmm 8/31/2009 20:20'!acceptMagritte: aVisitor	aVisitor visitDateAndTimeDescription: self! !MAMagnitudeDescription subclass: #MADateDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MADateDescription commentStamp: 'lr 4/10/2007 21:06' prior: 0!I am a description of dates, possible values are instances of ==Date==. My visual representation could be a date-picker.!!MADateDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Date! !!MADateDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MADateDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Date'! !!MADateDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitDateDescription: self! !MAMagnitudeDescription subclass: #MADurationDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MADurationDescription commentStamp: 'lr 4/10/2007 21:07' prior: 0!I am a description of durations, possible values are instances of ==Duration==.!!MADurationDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Duration! !!MADurationDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MADurationDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Duration'! !!MADurationDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitDurationDescription: self! !!MAMagnitudeDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMax	^ nil! !!MAMagnitudeDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMin	^ nil! !!MAMagnitudeDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionMax	^ self new		accessor: #max;		label: 'Maximum';		priority: 410;		yourself! !!MAMagnitudeDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionMin	^ self new		accessor: #min;		label: 'Min';		priority: 400;		yourself! !!MAMagnitudeDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitMagnitudeDescription: self! !!MAMagnitudeDescription methodsFor: 'testing' stamp: 'lr 8/18/2007 10:47'!isSortable	^ true! !!MAMagnitudeDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isWithinRange: anObject	^ (self min isNil or: [ self min <= anObject ])		and: [ self max isNil or: [ self max >= anObject ] ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!max	^ self propertyAt: #max ifAbsent: [ self class defaultMax ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 3/25/2009 19:31'!max: aMagnitudeOrNil	"Set the maximum for accepted values, or ==nil== if open."	self propertyAt: #max put: aMagnitudeOrNil! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!min	^ self propertyAt: #min ifAbsent: [ self class defaultMin ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 3/25/2009 19:31'!min: aMagnitudeOrNil	"Set the minimum for accepted values, or ==nil== if open."	self propertyAt: #min put: aMagnitudeOrNil! !!MAMagnitudeDescription methodsFor: 'conveniance' stamp: 'lr 4/10/2007 21:40'!min: aMinimumObject max: aMaximumObject	"Set the minimum and maximum of accepted values, or ==nil== if open."	self min: aMinimumObject; max: aMaximumObject! !!MAMagnitudeDescription methodsFor: 'accessing-messages' stamp: 'lr 7/25/2008 17:46'!rangeErrorMessage	| min max |	^ self propertyAt: #rangeErrorMessage ifAbsent: [		min := self toString: self min. max := self toString: self max.		(self min notNil and: [ self max notNil ])			ifTrue: [ ^ 'Input must be between ' , min , ' and ' , max ].		(self min notNil and: [ self max isNil ])			ifTrue: [ ^ 'Input must be above or equeal to ' , min ].		(self min isNil and: [ self max notNil ])			ifTrue: [ ^ 'Input must be below or equal to ' , max ] ]! !!MAMagnitudeDescription methodsFor: 'accessing-messages' stamp: 'lr 3/25/2009 19:31'!rangeErrorMessage: aString	self propertyAt: #rangeErrorMessage put: aString! !!MAMagnitudeDescription methodsFor: 'validation-private' stamp: 'lr 9/12/2007 17:27'!validateSpecific: anObject	super validateSpecific: anObject.	(self isWithinRange: anObject)		ifFalse: [ MARangeError description: self signal: self rangeErrorMessage ]! !MAMagnitudeDescription subclass: #MANumberDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MANumberDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of numbers, possible values are instances of ==Number== and all its subclasses, including ==Integer== and ==Float==. My visual representation could be a number input-box or even a slider-control.!!MANumberDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Number! !!MANumberDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MANumberDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Number'! !!MANumberDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitNumberDescription: self! !!MANumberDescription methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:16'!beInteger	self addCondition: (MACondition selector: #isInteger) labelled: 'No integer was entered'! !!MANumberDescription methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:16'!beNegative	self addCondition: (MACondition selector: #negative) labelled: 'No negative number was entered'! !!MANumberDescription methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:16'!bePositive	self addCondition: (MACondition selector: #positive) labelled: 'No positive number was entered'! !MAMagnitudeDescription subclass: #MATimeDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MATimeDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of times, possible values are instances of ==Time==. My visual representation could be a time-picker.!!MATimeDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Time! !!MATimeDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATimeDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Time'! !!MATimeDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitTimeDescription: self! !MAMagnitudeDescription subclass: #MATimeStampDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MATimeStampDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of timestamps, possible values are instances of ==TimeStamp==. My visual representation could be a date- and time-picker.!!MATimeStampDescription class methodsFor: 'accessing-defaults' stamp: 'jf 9/30/2009 00:19'!defaultKind	^ GRPlatform current magritteTimeStampClass! !!MATimeStampDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATimeStampDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Timestamp'! !!MATimeStampDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitTimeStampDescription: self! !MAElementDescription subclass: #MAReferenceDescription	instanceVariableNames: 'reference'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAReferenceDescription commentStamp: 'lr 2/12/2006 19:38' prior: 0!I am an abstract superclass for descriptions holding onto another description.!MAReferenceDescription subclass: #MAOptionDescription	instanceVariableNames: 'options'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAOptionDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am an abstract description of different options the user can choose from. My instance variable ==options== references the options I am representing. The options can be sorted or unsorted.!MAOptionDescription subclass: #MAMultipleOptionDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAMultipleOptionDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of multiple options, possible options are stored within the ==options== field, possible values are instances of ==Collection==. My visual representation could be a multi-select list or a group of check-boxes.!!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultDistinct	^ false! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Collection! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultOrdered	^ false! !!MAMultipleOptionDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionDistinct	^ MABooleanDescription new		accessor: #distinct;		label: 'Distinct';		priority: 250;		default: self defaultDistinct;		yourself! !!MAMultipleOptionDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionOrdered	^ MABooleanDescription new		accessor: #ordered;		label: 'Ordered';		priority: 260;		default: self defaultOrdered;		yourself! !!MAMultipleOptionDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAMultipleOptionDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Multiple-Option'! !!MAMultipleOptionDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitMultipleOptionDescription: self! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beDistinct	self distinct: true! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beIndefinite	self distinct: false! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beOrdered	self ordered: true! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beUnordered	self ordered: false! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!distinct	^ self propertyAt: #distinct ifAbsent: [ self class defaultDistinct ]! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!distinct: aBoolean	self propertyAt: #distinct put: aBoolean! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isDistinct	^ self distinct! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isOrdered	^ self ordered! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!ordered	^ self propertyAt: #ordered ifAbsent: [ self class defaultOrdered ]! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!ordered: aBoolean	self propertyAt: #ordered put: aBoolean! !!MAMultipleOptionDescription methodsFor: 'validating' stamp: 'lr 11/14/2006 17:59'!validateKind: anObject	super validateKind: anObject.	(anObject allSatisfy: [ :each | self options includes: each ])		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MAMultipleOptionDescription methodsFor: 'validating' stamp: 'lr 2/16/2007 08:49'!validateRequired: anObject	super validateRequired: anObject.	(self isRequired and: [ anObject isCollection and: [ anObject isEmpty ] ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultOptions	^ OrderedCollection new! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultSorted	^ false! !!MAOptionDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionDefault	^ nil! !!MAOptionDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionOptions	^ MAMemoDescription new		accessor: #optionsTextual;		label: 'Options';		priority: 410;		default: self defaultOptions;		yourself! !!MAOptionDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionSorted	^ MABooleanDescription new		accessor: #sorted;		label: 'Sorted';		priority: 240;		default: self defaultSorted;		yourself! !!MAOptionDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitOptionDescription: self! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!allOptions	^ self prepareOptions: self options copy! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 5/5/2006 19:31'!allOptionsWith: anObject	^ self prepareOptions: ((self shouldNotInclude: anObject)		ifFalse: [ self options copyWith: anObject ]		ifTrue: [ self options copy ])! !!MAOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beSorted	self sorted: true! !!MAOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beUnsorted	self sorted: false! !!MAOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isSorted	^ self sorted! !!MAOptionDescription methodsFor: 'private' stamp: 'lr 9/12/2007 17:27'!labelForOption: anObject	self propertyAt: #labels ifPresent: [ :labels |		labels at: anObject ifPresent: [ :value |			^ value ] ].	^ self reference toString: anObject! !!MAOptionDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!options	^ options ifNil: [ options := self class defaultOptions ]! !!MAOptionDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!options: anArray	options := anArray! !!MAOptionDescription methodsFor: 'accessing' stamp: 'lr 9/12/2007 17:27'!optionsAndLabels: aCollection	"Set the options to be the keys of aCollection and the labels to be the values of aCollection."	self options: (aCollection collect: [ :assoc | assoc key ]).	self propertyAt: #labels put: (aCollection		inject: IdentityDictionary new		into: [ :result :assoc | result add: assoc; yourself ])! !!MAOptionDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!optionsTextual	^ (self reference toStringCollection: self options)		asMultilineString! !!MAOptionDescription methodsFor: 'accessing-textual' stamp: 'lr 4/21/2007 18:30'!optionsTextual: aString	| lines |	lines := (aString ifNil: [ String new ]) lines.	^ self options: (self reference fromStringCollection: lines)! !!MAOptionDescription methodsFor: 'copying' stamp: 'lr 3/26/2007 11:45'!postCopy	super postCopy.	options := options copy! !!MAOptionDescription methodsFor: 'private' stamp: 'lr 9/24/2007 19:18'!prepareOptions: aCollection	^ self isSorted		ifFalse: [ aCollection asArray ]		ifTrue: [ 			aCollection asArray				sort: self sortBlock;				yourself ]! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 5/5/2006 19:31'!shouldNotInclude: anObject	^ anObject isNil or: [ self options includes: anObject ]! !!MAOptionDescription methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!sortBlock	^ [ :a :b | (self reference toString: a) caseInsensitiveLessOrEqual: (self reference toString: b) ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!sorted	^ self propertyAt: #sorted ifAbsent: [ self class defaultSorted ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:31'!sorted: aBoolean	self propertyAt: #sorted put: aBoolean! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!undefined: aString	super undefined: aString.	self reference isNil		ifFalse: [ self reference undefined: aString ]! !MAOptionDescription subclass: #MASingleOptionDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MASingleOptionDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of a single option, possible values are stored within the ==options== field, but I might also be extensible so that the user can add its own option. My visual representation could be a drop-down list or a group of option-buttons.!!MASingleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultExtensible	^ false! !!MASingleOptionDescription class methodsFor: 'accessing-descriptions' stamp: 'lr 4/10/2008 14:17'!descriptionExtensible	^ MABooleanDescription new		accessor: #extensible;		label: 'Extensible';		priority: 250;		default: self defaultExtensible;		yourself! !!MASingleOptionDescription class methodsFor: 'accessing-descriptions' stamp: 'mb 4/10/2008 02:03'!descriptionGroupBy	^ MASymbolDescription new		selectorAccessor: #groupBy;		label: 'Grouped by';		priority: 260;		default: nil;		yourself! !!MASingleOptionDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MASingleOptionDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Single-Option'! !!MASingleOptionDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitSingleOptionDescription: self! !!MASingleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beExtensible	self extensible: true! !!MASingleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beLimited	self extensible: false! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!extensible	^ self propertyAt: #extensible ifAbsent: [ self class defaultExtensible ]! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!extensible: aBoolean	self propertyAt: #extensible put: aBoolean! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 9/3/2008 11:43'!groupBy	^ self propertyAt: #groupBy ifAbsent: [ nil ]! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:31'!groupBy: anAccessor	"anAccessor to be sent to the options objects for getting their group."		self propertyAt: #groupBy put: anAccessor asAccessor! !!MASingleOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isExtensible	^ self extensible! !!MASingleOptionDescription methodsFor: 'testing' stamp: 'mb 4/10/2008 00:37'!isGrouped	^ self groupBy notNil! !!MASingleOptionDescription methodsFor: 'private' stamp: 'lr 10/12/2010 13:09'!prepareOptions: aCollection	^ self isRequired		ifTrue: [ super prepareOptions: aCollection ]		ifFalse: [ (Array with: nil) , (super prepareOptions: aCollection) ]! !!MASingleOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 10/12/2010 13:09'!shouldNotInclude: anObject	^ self isExtensible not or: [ super shouldNotInclude: anObject ]! !!MASingleOptionDescription methodsFor: 'validating' stamp: 'lr 10/12/2010 13:08'!validateKind: anObject	super validateKind: anObject.	(self options includes: anObject)		ifTrue: [ ^ self ].	self isExtensible		ifTrue: [ self reference validate: anObject ]		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MAReferenceDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultReference	^ MAStringDescription new! !!MAReferenceDescription class methodsFor: 'accessing-description' stamp: 'jf 9/17/2009 15:43'!descriptionReference	^ MAToOneRelationDescription new		accessor: #reference;		classes: [ MADescription withAllConcreteClasses ] magritteDynamicObject;		label: 'Description';		priority: 400;		beRequired;		yourself! !!MAReferenceDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitReferenceDescription: self! !!MAReferenceDescription methodsFor: 'copying' stamp: 'lr 3/26/2007 11:44'!postCopy	super postCopy.	reference := reference copy! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!reference	^ reference ifNil: [ reference := self class defaultReference ]! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!reference: aDescription	reference := aDescription! !MAReferenceDescription subclass: #MARelationDescription	instanceVariableNames: 'classes'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MARelationDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am an abstract description for descriptions representing a relation. My instance variable ==classes== references a collection of possible classes that I can relate to. If required the reference description will be automatically built from this list of classes.!!MARelationDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultClasses	^ Set new! !!MARelationDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultReference	^ nil! !!MARelationDescription class methodsFor: 'accessing-description' stamp: 'jf 9/17/2009 15:43'!descriptionClasses	^ MAMultipleOptionDescription new		accessor: #classes;		label: 'Classes';		priority: 400;		options: [ Smalltalk allClasses ] magritteDynamicObject;		reference: MAClassDescription new;		yourself! !!MARelationDescription class methodsFor: 'accessing-description' stamp: 'jf 9/17/2009 15:43'!descriptionReference	^ super descriptionReference		classes: [ MAContainer withAllConcreteClasses ] magritteDynamicObject;		beOptional;		yourself! !!MARelationDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitRelationDescription: self! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!allClasses	^ (Array withAll: self classes)		sort: [ :a :b | a label caseInsensitiveLessOrEqual: b label ];		yourself! !!MARelationDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!classes	^ classes ifNil: [ classes := self class defaultClasses ]! !!MARelationDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!classes: aCollection	classes := aCollection! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'lr 5/27/2006 17:20'!commonClass	"Answer a common superclass of the classes of the receiver. The algorithm is implemented to be as efficient as possible. The inner loop will be only executed the first few iterations."	| current |	self classes isEmpty		ifTrue: [ ^ self class descriptionContainer ].	current := self classes anyOne.	self classes do: [ :each |		[ each includesBehavior: current ]			whileFalse: [ current := current superclass ] ].	^ current! !!MARelationDescription methodsFor: 'copying' stamp: 'lr 3/26/2007 11:45'!postCopy	super postCopy.	classes := classes copy! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'lr 4/10/2007 21:42'!reference	"The reference within a ==*MARelationDescription*== is calculated automatically from all the classes of the receiver, if set to ==nil==. By setting the reference to a ==*MAContainer*== instance it is possible to customize the reference description."	^ super reference ifNil: [ self commonClass description ]! !MARelationDescription subclass: #MAToManyRelationDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAToManyRelationDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of an one-to-many relationship, possible values are instances of ==Collection==.!!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'dc 4/16/2006 18:53'!defaultDefinitive	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:24'!defaultKind	^ Collection! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'dc 4/15/2006 15:02'!defaultOrdered	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'dc 4/16/2006 19:16'!defaultSorted	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionDefinitive	^ MABooleanDescription new		accessor: #definitive;		label: 'Definitive';		priority: 265;		default: self defaultDefinitive;		yourself! !!MAToManyRelationDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionOrdered	^ MABooleanDescription new		accessor: #ordered;		label: 'Ordered';		priority: 260;		default: self defaultOrdered;		yourself! !!MAToManyRelationDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionSorted	^ MABooleanDescription new		accessor: #sorted;		label: 'Sorted';		priority: 240;		default: self defaultSorted;		yourself! !!MAToManyRelationDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ '1:m Relation'! !!MAToManyRelationDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitToManyRelationDescription: self! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 18:51'!beDefinitive	self definitive: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 18:56'!beModifiable	self definitive: false! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/15/2006 15:01'!beOrdered	self ordered: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 19:16'!beSorted	self sorted: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/15/2006 15:01'!beUnordered	self ordered: false! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 19:16'!beUnsorted	self sorted: false! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/16/2006 18:50'!definitive	^ self propertyAt: #definitive ifAbsent: [ self class defaultDefinitive ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/16/2006 18:51'!definitive: aBoolean	self propertyAt: #definitive put: aBoolean! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'dc 4/16/2006 18:51'!isDefinitive	^ self definitive! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'dc 4/15/2006 15:01'!isOrdered	^ self ordered! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'dc 4/16/2006 19:15'!isSorted	^ self sorted! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/15/2006 15:01'!ordered	^ self propertyAt: #ordered ifAbsent: [ self class defaultOrdered ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/15/2006 15:01'!ordered: aBoolean	self propertyAt: #ordered put: aBoolean! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/16/2006 19:15'!sorted	^ self propertyAt: #sorted ifAbsent: [ self class defaultSorted ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:32'!sorted: aBoolean	self propertyAt: #sorted put: aBoolean! !!MAToManyRelationDescription methodsFor: 'validating' stamp: 'lr 11/14/2006 18:00'!validateKind: anObject	super validateKind: anObject.	anObject do: [ :object |		(self classes anySatisfy: [ :class | object species includesBehavior: class ])			ifFalse: [ MAKindError description: self signal: self kindErrorMessage ] ]! !!MAToManyRelationDescription methodsFor: 'validating' stamp: 'lr 2/16/2007 08:50'!validateRequired: anObject	super validateRequired: anObject.	(self isRequired and: [ anObject isCollection and: [ anObject isEmpty ] ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !MAToManyRelationDescription subclass: #MAToManyScalarRelationDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAToManyScalarRelationDescription commentStamp: 'pmm 11/3/2006 17:48' prior: 0!Like MAToManyRelationDescription but for scalar values.!!MAToManyScalarRelationDescription class methodsFor: 'accessing' stamp: 'pmm 11/3/2006 21:09'!label	^ '1:m scalar Relation'! !!MAToManyScalarRelationDescription methodsFor: 'visiting' stamp: 'pmm 11/3/2006 21:09'!acceptMagritte: aVisitor	aVisitor visitToManyScalarRelationDescription: self! !MARelationDescription subclass: #MAToOneRelationDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAToOneRelationDescription commentStamp: '<historical>' prior: 0!I am a description of an one-to-one relationship.!!MAToOneRelationDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAToOneRelationDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ '1:1 Relation'! !!MAToOneRelationDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitToOneRelationDescription: self! !!MAToOneRelationDescription methodsFor: 'validating' stamp: 'lr 10/12/2010 10:01'!validateKind: anObject	super validateKind: anObject.	(self classes anySatisfy: [ :class | anObject species includesBehavior: class ])		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !MAReferenceDescription subclass: #MATableDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MATableDescription commentStamp: 'lr 5/17/2006 14:44' prior: 0!I am a description of tables, their cells and labels. I hold a reference to the description of my cells, that are all described using the same description. Possible values include instances of *MATableModel*.!!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultColumnLabels	^ OrderedCollection with: 'a' with: 'b' with: 'c'! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ MATableModel! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultRowLabels	^ OrderedCollection with: '1' with: '2' with: '3'! !!MATableDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionColumnLabels	^ MAMemoDescription new		accessor: #columnLabelsTextual;		label: 'Column Labels';		priority: 250;		yourself! !!MATableDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionDefault	^ nil! !!MATableDescription class methodsFor: 'accessing-description' stamp: 'lr 3/9/2006 11:33'!descriptionRequired	^ nil! !!MATableDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionRowLabels	^ MAMemoDescription new		accessor: #rowLabelsTextual;		label: 'Row Labels';		priority: 250;		yourself! !!MATableDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATableDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Table'! !!MATableDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitTableDescription: self! !!MATableDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!columnCount	^ self columnLabels size! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!columnLabels	^ self propertyAt: #columnLabels ifAbsent: [ self class defaultColumnLabels ]! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!columnLabels: aCollection	self propertyAt: #columnLabels put: aCollection! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!columnLabelsTextual	^ (MAStringDescription new toStringCollection: self columnLabels)		asMultilineString! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!columnLabelsTextual: aString	self columnLabels: (MAStringDescription new fromStringCollection: aString lines)! !!MATableDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!rowCount	^ self rowLabels size! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!rowLabels	^ self propertyAt: #rowLabels ifAbsent: [ self class defaultRowLabels ]! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!rowLabels: aCollection	self propertyAt: #rowLabels put: aCollection! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!rowLabelsTextual	^ (MAStringDescription new toStringCollection: self rowLabels)		asMultilineString! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!rowLabelsTextual: aString	self rowLabels: (MAStringDescription new fromStringCollection: aString lines)! !!MATableDescription methodsFor: 'validation-private' stamp: 'lr 10/12/2010 13:18'!validateSpecific: anObject	| errors |	super validateSpecific: anObject.	(anObject rowCount ~= self rowCount or: [ anObject columnCount ~= self columnCount ])		ifTrue: [ MAKindError description: self signal: self kindErrorMessage ].	errors := OrderedCollection new.	anObject do: [ :row :value :each | 		[ self reference validate: each ]			on: MAValidationError			do: [ :err | errors add: err ] ].	errors isEmpty ifFalse: [		MAMultipleErrors			description: self 			errors: errors			signal: self label ]! !MAReferenceDescription subclass: #MATokenDescription	instanceVariableNames: 'separators'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MATokenDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of tokens all described by the referenced description, possible values are instances of ==SequenceableCollection==.!!MATokenDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:24'!defaultKind	^ Array! !!MATokenDescription class methodsFor: 'accessing-defaults' stamp: 'jf 9/18/2009 14:28'!defaultSeparators	^ ' ,;', (String with: Character cr with: Character lf with: Character tab)! !!MATokenDescription class methodsFor: 'accessing-description' stamp: 'lr 2/5/2009 10:45'!descriptionSeparators	^ MAStringDescription new		accessor: #separators;		label: 'Separators';		priority: 250;		yourself! !!MATokenDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATokenDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Token'! !!MATokenDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitTokenDescription: self! !!MATokenDescription methodsFor: 'accessing' stamp: 'lr 2/5/2009 10:46'!separators	^ separators ifNil: [ separators := self class defaultSeparators ]! !!MATokenDescription methodsFor: 'accessing' stamp: 'lr 2/5/2009 10:57'!separators: aString	"A string with the separator characters to split tokens, the first character is used as a default for printing."	separators := aString! !MAElementDescription subclass: #MAStringDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAStringDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of strings, possible values are instances of ==String==. My visual representation could be a single line text-field. Use ==*MAMemoDescription*== for multi-line strings.!MAStringDescription subclass: #MAMemoDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAMemoDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of multiline strings, possible values are instances of ==String==. My visual representation could be a text-area field.!!MAMemoDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultLineCount	^ 3! !!MAMemoDescription class methodsFor: 'accessing-description' stamp: 'lr 4/10/2008 14:17'!descriptionLineCount	^ MANumberDescription new		accessor: #lineCount;		label: 'Number of Lines';		priority: 400;		default: self defaultLineCount;		beInteger;		min: 1;		yourself! !!MAMemoDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Memo'! !!MAMemoDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitMemoDescription: self! !!MAMemoDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!lineCount	^ self propertyAt: #lineCount ifAbsent: [ self class defaultLineCount ]! !!MAMemoDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:31'!lineCount: anInteger	self propertyAt: #lineCount put: anInteger! !MAStringDescription subclass: #MAPasswordDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MAPasswordDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of a password string, possible values are instances of ==String==. My visual representation could be a password field, where there are stars printed instead of the characters the user enters.!!MAPasswordDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Password'! !!MAPasswordDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitPasswordDescription: self! !!MAPasswordDescription methodsFor: 'testing' stamp: 'lr 9/26/2007 18:32'!isObfuscated: anObject	^ anObject notNil		and: [ anObject isString		and: [ anObject isEmpty not		and: [ anObject allSatisfy: [ :each | each = $* ] ] ] ]! !!MAPasswordDescription methodsFor: 'testing' stamp: 'lr 8/18/2007 10:47'!isSortable	^ false! !!MAPasswordDescription methodsFor: 'operators' stamp: 'AvO 3/12/2012 12:46'!obfuscated: anObject	^ (String new: (self toString: anObject) size) atAllPut: $*! !!MAStringDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ String! !!MAStringDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAStringDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'String'! !!MAStringDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitStringDescription: self! !!MAStringDescription methodsFor: 'testing' stamp: 'lr 8/18/2007 10:47'!isSortable	^ true! !MAStringDescription subclass: #MASymbolDescription	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Description'!!MASymbolDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of symbols, possible values are instances of ==Symbol==.!!MASymbolDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Symbol! !!MASymbolDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Symbol'! !!MASymbolDescription methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor	aVisitor visitSymbolDescription: self! !MAObject subclass: #MAMemento	instanceVariableNames: 'model description'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Memento'!!MAMemento commentStamp: 'lr 9/13/2007 09:53' prior: 0!I am an abstract memento. I reference a model I am working on and the description currently used to describe this model.!MAMemento subclass: #MACachedMemento	instanceVariableNames: 'cache'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Memento'!!MACachedMemento commentStamp: 'lr 5/29/2006 09:22' prior: 0!I cache values being read and written without touching the model. When committing changes, the modifications will be propagated to the model all at once.!!MACachedMemento class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MACachedMemento methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!cache	^ cache! !!MACachedMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:31'!commit	super commit.	self push: self cache.	self reset! !!MACachedMemento methodsFor: 'testing' stamp: 'lr 5/14/2008 20:28'!hasChanged	"Answer ==true==, if the cached data is different to the data in the model."	^ self isDifferent: self cache to: self pullRaw! !!MACachedMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!readUsing: aDescription	^ self cache at: aDescription! !!MACachedMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:31'!reset	super reset.	self setCache: self pull! !!MACachedMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:31'!setCache: aDictionary	cache := aDictionary! !!MACachedMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!write: anObject using: aDescription	self cache at: aDescription put: anObject! !MACachedMemento subclass: #MACheckedMemento	instanceVariableNames: 'original'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Memento'!!MACheckedMemento commentStamp: 'lr 5/17/2006 15:12' prior: 0!I cache values as my superclass and also remember the original values of the model at the time the cache is built. With this information I am able to detect edit conflicts and can prevent accidental loss of data by merging the changes.!!MACheckedMemento methodsFor: 'testing' stamp: 'lr 5/14/2008 20:26'!hasConflict	"Answer ==true==, if there is an edit conflict."	^ self hasChanged and: [ self isDifferent: self original to: self pullRaw ]! !!MACheckedMemento methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!original	^ original! !!MACheckedMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:31'!reset	super reset.	self setOriginal: self pullRaw! !!MACheckedMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:31'!setOriginal: aDictionary	original := aDictionary! !!MACheckedMemento methodsFor: 'actions' stamp: 'lr 5/14/2008 20:28'!validate	self hasConflict		ifFalse: [ ^ super validate ].	self reset.	MAConflictError		description: self description		signal: self description conflictErrorMessage! !!MAMemento class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!model: aModel	^ self model: aModel description: aModel description! !!MAMemento class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!model: aModel description: aDescription	^ self new		setModel: aModel;		setDescription: aDescription;		reset; yourself! !!MAMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!commit	"Commit the receiver into the model."! !!MAMemento methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!description	^ description! !!MAMemento methodsFor: 'private' stamp: 'lr 5/14/2008 20:27'!isDifferent: firstDictionary to: secondDictionary	| firstValue secondValue |	self description do: [ :each |		(each isVisible and: [ each isReadonly not ]) ifTrue: [			firstValue := firstDictionary at: each ifAbsent: [ nil ].			secondValue := secondDictionary at: each ifAbsent: [ nil ].			firstValue = secondValue ifFalse: [ ^ true ] ] ].	^ false! !!MAMemento methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!model	^ model! !!MAMemento methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' model: '; print: self model! !!MAMemento methodsFor: 'private' stamp: 'lr 2/8/2009 19:20'!pull	"Utility method to pull the model into a dictionary mapping descriptions to values. nil values are replaced with the default ones of the model."	| result |	result := self pullRaw.	result keysAndValuesDo: [ :key :value |		value isNil			ifTrue: [ result at: key put: key default yourself ] ].	^ result! !!MAMemento methodsFor: 'private' stamp: 'lr 5/14/2008 20:22'!pullRaw	| result |	result := Dictionary new.	self description do: [ :each |		result at: each put: (self model			readUsing: each) ].	^ result! !!MAMemento methodsFor: 'private' stamp: 'lr 2/8/2009 19:20'!push: aDictionary	"Utility method to push a dictionary mapping descriptions to values into the model."	aDictionary keysAndValuesDo: [ :key :value |		(key isVisible and: [ key isReadonly not ]) 			ifTrue: [ self model write: value using: key ] ]! !!MAMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!reset	"Reset the memento from the model."! !!MAMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setDescription: aDescription	description := aDescription! !!MAMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setModel: aModel	model := aModel! !!MAMemento methodsFor: 'actions' stamp: 'lr 5/29/2006 09:23'!validate	"Check if the data in the receiver would be valid if committed. In case of problems an exception is raised."	self description validate: self! !MAMemento subclass: #MAStraitMemento	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Memento'!!MAStraitMemento commentStamp: 'lr 5/17/2006 15:02' prior: 0!I am a memento that forwards read- and write-access directly to the model. I can mostly be replaced with the model itself.!!MAStraitMemento class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAStraitMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!readUsing: aDescription	^ (self model readUsing: aDescription)		ifNil: [ aDescription default ]! !!MAStraitMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!write: anObject using: aDescription	self model write: anObject using: aDescription! !!MAObject class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ true! !!MAObject class methodsFor: 'instance creation' stamp: 'jf 9/16/2009 12:27'!new	"Create a new instance of the receiving class and checks if it is concrete."	self isAbstract		ifTrue: [ self error: self name , ' is abstract.' ].	^ super new! !!MAObject class methodsFor: 'reflection' stamp: 'lr 3/9/2006 11:33'!withAllConcreteClasses	^ Array streamContents: [ :stream |		self withAllConcreteClassesDo: [ :each |			stream nextPut: each ] ]! !!MAObject class methodsFor: 'reflection' stamp: 'lr 3/9/2006 11:33'!withAllConcreteClassesDo: aBlock	self withAllSubclassesDo: [ :each |		each isAbstract ifFalse: [			aBlock value: each ] ]! !!MAObject methodsFor: 'comparing' stamp: 'lr 4/10/2007 21:40'!= anObject	"Answer whether the receiver and the argument represent the same object. This default implementation checks if the species of the compared objects are the same, so that superclasses might call super before performing their own check. Also redefine the message ==#hash== when redefining this message."	^ self species = anObject species! !!MAObject methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor! !!MAObject methodsFor: 'private' stamp: 'lr 4/10/2008 14:11'!errorPropertyNotFound: aSelector 	MAPropertyError signal: 'Property ' , aSelector , ' not found.'! !!MAObject methodsFor: 'testing' stamp: 'lr 4/10/2007 21:40'!hasProperty: aKey	"Test if the property ==aKey== is defined within the receiver."	^ self properties includesKey: aKey! !!MAObject methodsFor: 'comparing' stamp: 'lr 4/10/2007 21:40'!hash	"Answer a SmallInteger whose value is related to the receiver's identity. Also redefine the message ==#= == when redefining this message."	^ self species hash! !!MAObject methodsFor: 'copying' stamp: 'lr 5/29/2006 09:05'!postCopy	"This method is called whenever a shallow copy of the receiver is made. Redefine this method in subclasses to copy other fields as necessary. Never forget to call super, else class invariants might be violated."	super postCopy.	properties := properties copy! !!MAObject methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!properties	"Answer the property dictionary of the receiver."	^ properties ifNil: [ properties := Dictionary new ]! !!MAObject methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:41'!propertyAt: aKey	"Answer the value of the property ==aKey==, raises an error if the property doesn't exist."	^ self propertyAt: aKey ifAbsent: [ self errorPropertyNotFound: aKey ]! !!MAObject methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:54'!propertyAt: aKey ifAbsent: aBlock	"Answer the value of the property ==aKey==, or the result of ==aBlock== if the property doesn't exist."	^ self properties at: aKey ifAbsent: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:41'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the value of the property ==aKey==, or if the property doesn't exist adds and answers the result of evaluating ==aBlock==."	^ self properties at: aKey ifAbsentPut: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'lr 4/12/2007 19:49'!propertyAt: aKey ifPresent: aBlock	"Lookup the property ==aKey==, if it is present, answer the value of evaluating ==aBlock== block with the value. Otherwise, answer ==nil==."	^ self properties at: aKey ifPresent: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:41'!propertyAt: aKey put: aValue	"Adds or replaces the property ==aKey== with ==aValue==."	^ self properties at: aKey put: aValue! !MABasicObject subclass: #MASortBlock	instanceVariableNames: 'accessor selector'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Utility'!!MASortBlock class methodsFor: 'instance creation' stamp: 'lr 4/10/2008 13:50'!accessor: anAccessor selector: aSelector	^ self basicNew initializeAccessor: anAccessor selector: aSelector! !!MASortBlock class methodsFor: 'instance creation' stamp: 'lr 4/10/2008 13:55'!selector: aSelector 	^ self 		accessor: MAIdentityAccessor new		selector: aSelector! !!MASortBlock methodsFor: 'actions' stamp: 'lr 4/10/2008 14:01'!fixTemps! !!MASortBlock methodsFor: 'initialization' stamp: 'lr 4/10/2008 13:41'!initializeAccessor: anAccessor selector: aSelector	accessor := anAccessor asAccessor.	selector := aSelector! !!MASortBlock methodsFor: 'evaluating' stamp: 'lr 4/10/2008 13:42'!value: aFirstObject value: aSecondObject	^ (accessor read: aFirstObject)		perform: selector		with: (accessor read: aSecondObject)! !MABasicObject subclass: #MATableModel	instanceVariableNames: 'rowCount columnCount contents'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Models'!!MATableModel commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a model class representing a table within the Magritte framework. Internally I store my cells within a flat array, however users may access data giving ''row'' and ''column'' coordinates with ==#at:at:== and ==#at:at:put:==. I can support reshaping myself, but of course this might lead to loss of data-cells.!!MATableModel class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!rows: aRowCount columns: aColumnCount	^ self rows: aRowCount columns: aColumnCount contents: (Array new: aRowCount * aColumnCount)! !!MATableModel class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!rows: aRowCount columns: aColumnCount contents: anArray	^ self new		setRowCount: aRowCount;		setColumnCount: aColumnCount;		setContents: anArray;		yourself! !!MATableModel methodsFor: 'comparing' stamp: 'lr 2/16/2007 08:50'!= aTable	^ self species = aTable species		and: [ self rowCount = aTable rowCount		and: [ self columnCount = aTable columnCount		and: [ self contents = aTable contents ] ] ]! !!MATableModel methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:42'!at: aRowIndex at: aColumnIndex	"Answer the contents of ==aRowIndex== and ==aColumnIndex==. Raises an error if the coordinates are out of bounds."	self checkAt: aRowIndex at: aColumnIndex.	^ self uncheckedAt: aRowIndex at: aColumnIndex! !!MATableModel methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:43'!at: aRowIndex at: aColumnIndex put: aValue	"Set the contents of ==aRowIndex== and ==aColumnIndex==> to ==aValue==. Raises an error if the coordinates are out of bounds."	self checkAt: aRowIndex at: aColumnIndex.	^ self uncheckedAt: aRowIndex at: aColumnIndex put: aValue! !!MATableModel methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!checkAt: aRowIndex at: aColumnIndex	(aRowIndex between: 1 and: self rowCount)		ifFalse: [ self error: 'Row subscript out of range.' ].	(aColumnIndex between: 1 and: self columnCount)		ifFalse: [ self error: 'Column subscript out of range.' ]! !!MATableModel methodsFor: 'enumeration' stamp: 'lr 3/28/2007 10:28'!collect: aBlock	| copy |	copy := self copyEmpty.	self do: [ :row :col :val |		copy			at: row at: col			put: (aBlock value: row value: col value: val) ].	^ copy! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!columnCount	"Answer the column count of the table."	^ columnCount! !!MATableModel methodsFor: 'accessing' stamp: 'lr 10/12/2010 13:14'!contents	"Answer the contents array of the receiver."	^ contents! !!MATableModel methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyEmpty	^ self class rows: self rowCount columns: self columnCount! !!MATableModel methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyRows: aRowCount columns: aColumnCount	| table |	table := self class rows: aRowCount columns: aColumnCount.	1 to: (self rowCount min: aRowCount) do: [ :row |		1 to: (self columnCount min: aColumnCount) do: [ :col |			table				uncheckedAt: row at: col				put: (self uncheckedAt: row at: col) ] ].	^ table! !!MATableModel methodsFor: 'enumeration' stamp: 'lr 3/9/2006 11:32'!do: aBlock	1 to: self rowCount do: [ :row |		1 to: self columnCount do: [ :col |			aBlock				value: row value: col				value: (self uncheckedAt: row at: col) ] ]! !!MATableModel methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ self contents hash! !!MATableModel methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!indexAt: aRowIndex at: aColumnIndex	^ (aRowIndex - 1) * self columnCount + aColumnIndex! !!MATableModel methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!pointAt: anIndex	^ Point x: (anIndex - 1 // self columnCount + 1) y: (anIndex - 1 \\ self columnCount + 1)! !!MATableModel methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!postCopy	super postCopy.	self setContents: self contents copy! !!MATableModel methodsFor: 'operations' stamp: 'lr 4/10/2007 21:43'!reshapeRows: aRowCount columns: aColumnCount	"Change the size of the receiving table to ==aRowCount== times ==aColumnCount==, throwing away elements that are cut off and initializing empty cells with ==nil==."	self setContents: (self copyRows: aRowCount columns: aColumnCount) contents.	self setRowCount: aRowCount; setColumnCount: aColumnCount! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!rowCount	"Answer the row count of the table."	^ rowCount! !!MATableModel methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setColumnCount: anInteger	columnCount := anInteger! !!MATableModel methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setContents: anArray	contents := anArray! !!MATableModel methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setRowCount: anInteger	rowCount := anInteger! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uncheckedAt: aRowIndex at: aColumnIndex	^ self contents at: (self indexAt: aRowIndex at: aColumnIndex)! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uncheckedAt: aRowIndex at: aColumnIndex put: aValue	^ self contents at: (self indexAt: aRowIndex at: aColumnIndex) put: aValue! !MABasicObject subclass: #MAValueHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Utility'!MAValueHolder subclass: #MADescriptionHolder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Utility'!!MADescriptionHolder class methodsFor: 'accessing' stamp: 'lr 10/29/2009 20:55'!descriptionClasses	^ MAElementDescription withAllConcreteClasses asOrderedCollection! !!MADescriptionHolder class methodsFor: 'accessing' stamp: 'lr 10/29/2009 20:56'!descriptionValue	^ MASingleOptionDescription new		reference: MAClassDescription new;		options: self descriptionClasses;		selectorAccessor: 'contents';		groupBy: #grouping;		label: 'Type';		priority: 20;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:59'!groupChoice	^ Set new		add: MABooleanDescription;		add: MASingleOptionDescription;		add: MAMultipleOptionDescription;		add: MAToOneRelationDescription;		add: MAToManyRelationDescription;		add: MAToManyScalarRelationDescription;				yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:58'!groupMagnitude	^ Set new		add: MANumberDescription;		add: MADurationDescription;		add: MADateDescription;		add: MATimeDescription;		add: MATimeStampDescription;		add: MADateAndTimeDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:55'!groupMisc	^ Set new		add: MAFileDescription;		add: MAClassDescription;		add: MATableDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:57'!groupOf: aClass 	(self groupText includes: aClass)		ifTrue: [ ^ 'Text' ].	(self groupChoice includes: aClass)		ifTrue: [ ^ 'Choice' ].	(self groupMagnitude includes: aClass)		ifTrue: [ ^ 'Magnitude' ].	(self groupPick includes: aClass)		ifTrue: [ ^ 'Pick' ].	(self groupMisc includes: aClass)		ifTrue: [ ^ 'Miscellaneous' ].	^ 'Other'! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:56'!groupPick	^ Set new		add: MAColorDescription;		add: MATokenDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:56'!groupText	^ Set new		add: MAStringDescription;		add: MAMemoDescription;		add: MASymbolDescription;		add: MAPasswordDescription;		yourself! !!MADescriptionHolder methodsFor: 'initialization' stamp: 'lr 8/14/2008 11:44'!initialize	super initialize.	self contents: self class descriptionClasses first! !!MAValueHolder class methodsFor: 'instance creation' stamp: 'lr 8/14/2008 11:45'!on: anObject	^ self new contents: anObject! !!MAValueHolder methodsFor: 'accessing' stamp: 'lr 8/14/2008 11:43'!contents	^ contents! !!MAValueHolder methodsFor: 'accessing' stamp: 'lr 8/14/2008 11:43'!contents: anObject	contents := anObject! !MABasicObject subclass: #MAVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Visitor'!!MAVisitor commentStamp: 'lr 5/17/2006 15:27' prior: 0!I am a visitor responsible to visit Magritte descriptions. I am an abstract class providing a default implementation for concrete visitors. The protocol I am implementing reflects the hierarchy of *MADescription* with its subclasses so that visiting a specific class automatically calls less specific implementations in case the specific implementation has been left out. The code was automatically created using code on my class-side.!MAVisitor subclass: #MAStreamingVisitor	instanceVariableNames: 'stream object'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Visitor'!MAStreamingVisitor subclass: #MAReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Visitor'!!MAReader class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!read: aStream description: aDescription	^ self new read: aStream description: aDescription! !!MAReader methodsFor: 'private' stamp: 'lr 4/10/2008 14:11'!error: aString 	MAReadError signal: aString! !!MAReader methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!read: aStream description: aDescription	self		stream: aStream;		visit: aDescription.	^ self object! !MAReader subclass: #MAStringReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Visitor'!!MAStringReader methodsFor: 'private' stamp: 'lr 5/21/2009 13:36'!nextMatchAll: aCollection on: aStream	"Tries to match ==aCollection== on ==aStream==. Answer ==true== if ==aCollection== was consumed, otherwise ==false==."	| position |	(aCollection isNil or: [ aCollection isEmpty ])		ifTrue: [ ^ false ].	position := aStream position.	aCollection do: [ :char |		(aStream atEnd or: [ aStream next ~= char ]) ifTrue: [			aStream position: position.			^ false ] ].	^ true! !!MAStringReader methodsFor: 'visiting' stamp: 'lr 5/21/2009 13:34'!read: aStream description: aDescription	(aStream atEnd or: [ self nextMatchAll: aDescription undefined on: aStream ])		ifTrue: [ ^ nil ].	^ super read: aStream description: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 4/10/2008 14:10'!visitBooleanDescription: aDescription	(aDescription trueString = self contents		or: [ aDescription trueStrings includes: self contents ])			ifTrue: [ ^ self object: true ].	(aDescription falseString = self contents		or: [ aDescription falseStrings includes: self contents ])			ifTrue: [ ^ self object: false ].	MAReadError signal! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitClassDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 4/10/2008 14:10'!visitColorDescription: aDescription	(self contents notEmpty and: [ self contents allSatisfy: [ :each | '#0123456789ABCDEFabcdef.' includes: each ] ])		ifFalse: [ MAReadError signal ].	self object: (aDescription kind fromString: self contents)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitContainer: anObject	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 4/10/2008 14:10'!visitDurationDescription: aDescription	| contents |	contents := self contents.	contents isEmpty		ifTrue: [ MAReadError signal ].	(contents occurrencesOf: $-) > 1		ifTrue: [ MAReadError signal ].	(contents indexOf: $-) > 1		ifTrue: [ MAReadError signal ].	(contents occurrencesOf: $.) > 1		ifTrue: [ MAReadError signal ].	(contents allSatisfy: [:each | '-0123456789.:' includes: each])		ifFalse: [ MAReadError signal ].	super visitDurationDescription: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 4/10/2008 14:11'!visitElementDescription: aDescription	"This implementation can be very dangerous and might lead to a potential security hole (this is tested), since the default implementation of #readFrom: in Object evaluates the expression to find its value. Most subclasses like Number, Date, Time, ... override this implementation, but some others (like Boolean) do not."	self object: ([ aDescription kind readFrom: self stream ]		on: Error do: [ :err | MAReadError signal: err messageText ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitFileDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 1/18/2008 19:18'!visitMultipleOptionDescription: aDescription	self object: (Array streamContents: [ :output |		[ self stream atEnd ] whileFalse: [			output nextPut: (aDescription reference				fromString: (self stream upTo: $,)).			self stream peek = Character space				ifTrue: [ self stream next ] ] ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 4/10/2008 14:10'!visitNumberDescription: aDescription	| contents |	contents := self contents.	contents isEmpty		ifTrue: [ MAReadError signal ].	(contents occurrencesOf: $-) > 1		ifTrue: [ MAReadError signal ].	(contents indexOf: $-) > 1		ifTrue: [ MAReadError signal ].	(contents occurrencesOf: $.) > 1		ifTrue: [ MAReadError signal ].	(contents allSatisfy: [ :each | '+-0123456789.eE' includes: each ])		ifFalse: [ MAReadError signal ].	super visitNumberDescription: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitRelationDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 5/21/2009 13:39'!visitSingleOptionDescription: aDescription	aDescription propertyAt: #labels ifPresent: [ :labels |		labels keysAndValuesDo: [ :key :value |			(self nextMatchAll: value on: self stream)				ifTrue: [ ^ self object: key ] ] ].	self visit: aDescription reference! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitStringDescription: aDescription	self object: self contents! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitSymbolDescription: aDescription	self object: self contents asSymbol! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTableDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 4/10/2008 14:10'!visitTimeDescription: aDescription	| string |	string := self contents.	(string notEmpty and: [ string allSatisfy: [ :each | '0123456789: apm' includes: each ] ])		ifFalse: [ MAReadError signal ].	self object: (aDescription kind readFrom: string readStream)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 2/5/2009 10:52'!visitTokenDescription: aDescription	| token |	self object: (aDescription kind streamContents: [ :output |		[ self stream atEnd ] whileFalse: [			token := WriteStream on: String new.			[ self stream atEnd or: [ aDescription separators includes: self stream peek ] ]				whileFalse: [ token nextPut: self stream next ].			self stream atEnd 				ifFalse: [ self stream next ].			token contents isEmpty				ifFalse: [ output nextPut: (aDescription reference fromString: token contents) ] ] ])! !!MAStreamingVisitor methodsFor: 'streaming' stamp: 'lr 3/9/2006 11:32'!contents	^ self stream contents! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!object	^ object! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!object: anObject	object := anObject! !!MAStreamingVisitor methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!object: anObject during: aBlock	| previous |	previous := self object. self object: anObject.	aBlock ensure: [ self object: previous ]! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!stream	^ stream! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!stream: aStream	stream := aStream! !MAStreamingVisitor subclass: #MAWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Visitor'!MAWriter subclass: #MAStringWriter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Visitor'!!MAStringWriter methodsFor: 'private' stamp: 'lr 5/21/2009 13:24'!defaultWriteStream	^ WriteStream on: String new! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitBooleanDescription: aDescription	self stream nextPutAll: (self object		ifTrue: [ aDescription trueString ]		ifFalse: [ aDescription falseString ])! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitClassDescription: aDescription	self stream nextPutAll: self object label! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitColorDescription: aDescription	stream nextPut: $#.	stream nextPutAll: ((255 * self object red) asInteger		printPaddedWith: $0 to: 2 base: 16).	stream nextPutAll: ((255 * self object green) asInteger		printPaddedWith: $0 to: 2 base: 16).	stream nextPutAll: ((255 * self object blue) asInteger		printPaddedWith: $0 to: 2 base: 16)! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitContainer: aDescription	aDescription do: [ :each |		each isVisible ifTrue: [			each stringWriter				write: (self object readUsing: each)				description: each to: stream.			^ self ] ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'pmm 8/31/2009 20:18'!visitDateAndTimeDescription: aDescription	self stream print: self object! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'jf 9/30/2009 01:10'!visitElementDescription: aDescription 	self stream nextPutAll: self object greaseString! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitFileDescription: aDescription	self stream nextPutAll: self object filename! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 5/21/2009 13:23'!visitMultipleOptionDescription: aDescription	self object isEmpty		ifTrue: [ self stream nextPutAll: aDescription undefined ]		ifFalse: [			self object				do: [ :each | self stream nextPutAll: (aDescription labelForOption: each) ]				separatedBy: [ self stream nextPutAll: ', ' ] ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 5/21/2009 13:21'!visitSingleOptionDescription: aDescription	self stream nextPutAll: (aDescription labelForOption: self object)! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'jf 9/30/2009 01:10'!visitTimeDescription: aDescription 	| time |	time := self object.	self stream		nextPutAll: time hour greaseString;		nextPut: $:;		nextPutAll: time minute greaseString;		nextPut: $:;		nextPutAll: time second greaseString! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'jf 9/18/2009 10:47'!visitTimeStampDescription: aDescription	self stream print: self object date; space.	self stream print: self object time! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitToManyRelationDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: each description ] ]		separatedBy: [ self stream nextPutAll: ', ' ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitToOneRelationDescription: aDescription	self visit: self object description! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 2/5/2009 10:48'!visitTokenDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: aDescription reference ] ]		separatedBy: [ self stream nextPut: aDescription separators first ]! !!MAStringWriter methodsFor: 'visiting' stamp: 'lr 5/21/2009 13:25'!write: anObject description: aDescription to: aStream	anObject isNil 		ifTrue: [ aStream nextPutAll: aDescription undefined ]		ifFalse: [ super write: anObject description: aDescription to: aStream ].	^ aStream contents! !!MAWriter class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!write: anObject	^ self new write: anObject! !!MAWriter class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!write: anObject description: aDescription	^ self new write: anObject description: aDescription! !!MAWriter class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!write: anObject description: aDescription to: aStream	^ self new write: anObject description: aDescription to: aStream! !!MAWriter methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!defaultWriteStream	self subclassResponsibility! !!MAWriter methodsFor: 'private' stamp: 'lr 4/10/2008 14:12'!error: aString 	MAWriteError signal: aString! !!MAWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!write: anObject	^ self write: anObject description: anObject description! !!MAWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!write: anObject description: aDescription	^ self write: anObject description: aDescription to: self defaultWriteStream! !!MAWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!write: anObject description: aDescription to: aStream	self		object: anObject;		stream: aStream;		visit: aDescription.	^ self contents! !MAVisitor subclass: #MAValidatorVisitor	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Visitor'!!MAValidatorVisitor class methodsFor: 'instance creation' stamp: 'lr 2/16/2007 08:32'!on: anObject description: aDescription	^ self new on: anObject description: aDescription! !!MAValidatorVisitor methodsFor: 'accessing' stamp: 'lr 10/12/2010 09:56'!object	"Answer the currently validated object."	^ object! !!MAValidatorVisitor methodsFor: 'initialization' stamp: 'lr 11/6/2009 15:50'!on: anObject description: aDescription	self use: anObject during: [ self visit: aDescription ]! !!MAValidatorVisitor methodsFor: 'private' stamp: 'lr 10/12/2010 09:55'!use: anObject during: aBlock	| previous |	previous := object. object := anObject.	^ aBlock ensure: [ object := previous ]! !!MAValidatorVisitor methodsFor: 'private' stamp: 'lr 10/12/2010 09:52'!validate: anObject using: aDescription	aDescription validateRequired: anObject.	anObject isNil ifTrue: [ ^ self ].	aDescription		validateKind: anObject;		validateSpecific: anObject;		validateConditions: anObject! !!MAValidatorVisitor methodsFor: 'visiting' stamp: 'lr 10/12/2010 09:53'!visit: aDescription	"Only visit objects that are visible and that can be changed."		(aDescription isVisible and: [ aDescription isReadonly not ])		ifTrue: [ super visit: aDescription ].	! !!MAValidatorVisitor methodsFor: 'visiting-descriptions' stamp: 'lr 10/12/2010 09:57'!visitContainer: aDescription	| errors |	super visitContainer: aDescription.	self object isNil ifTrue: [ ^ self ].	errors := OrderedCollection new.	aDescription do: [ :description |		[ self			use: (self object readUsing: description)			during: [ self visit: description ] ]				on: MAValidationError				do: [ :err | errors add: err ] ].	errors isEmpty ifFalse: [		MAMultipleErrors			description: aDescription 			errors: errors			signal: aDescription label ]! !!MAValidatorVisitor methodsFor: 'visiting-descriptions' stamp: 'lr 11/6/2009 09:23'!visitDescription: aDescription	self validate: self object using: aDescription! !!MAVisitor class methodsFor: 'private' stamp: 'AvO 3/12/2012 16:38'!buildVisitorHierarchyForClass: aClass selector: aBlock classified: aSelector	" self buildVisitorHierarchyForClass: MADescription selector: [ :class | 'visit' , (class name allButFirst: 2) , ':' ] classified: #'visiting-description' "	aClass withAllSubclassesDo: [ :class |		(class category beginsWithSubCollection: 'Magritte') ifTrue: [			self				compile: (String streamContents: [ :stream |					stream nextPutAll: (aBlock value: class); nextPutAll: ' anObject'; cr.					class = aClass ifFalse: [						stream tab; nextPutAll: 'self '; nextPutAll: (aBlock value: class superclass); nextPutAll: ' anObject.' ] ])				classified: aSelector.			class				compile: (String streamContents: [ :stream |					stream nextPutAll: 'acceptMagritte: aVisitor'; cr.					stream tab; nextPutAll: 'aVisitor '; nextPutAll: (aBlock value: class); nextPutAll: ' self.' ])				classified: #visiting ] ]! !!MAVisitor methodsFor: 'visiting' stamp: 'lr 4/10/2007 21:43'!visit: anObject	"Visit ==anObject== with the receiving visitor."	anObject acceptMagritte: self! !!MAVisitor methodsFor: 'visiting' stamp: 'lr 4/10/2007 21:43'!visitAll: aCollection	"Visit all elements of ==aCollection== with the receiving visitor."	aCollection do: [ :each | self visit: each ]! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitBooleanDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitClassDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitColorDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitContainer: anObject	self visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'pmm 8/31/2009 20:08'!visitDateAndTimeDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitDateDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitDurationDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitElementDescription: anObject	self visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitFileDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitMagnitudeDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitMemoDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitMultipleOptionDescription: anObject	self visitOptionDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitNumberDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitOptionDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitPasswordDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitPriorityContainer: anObject	self visitContainer: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitReferenceDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitRelationDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitReportContainer: anObject	self visitContainer: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitSingleOptionDescription: anObject	self visitOptionDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitStringDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitSymbolDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTableDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTableReference: anObject	^ self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTimeDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'pmm 8/31/2009 20:08'!visitTimeStampDescription: anObject	self visitDateAndTimeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitToManyRelationDescription: anObject	self visitRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'pmm 11/3/2006 21:09'!visitToManyScalarRelationDescription: anObject	self visitToManyRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitToOneRelationDescription: anObject	self visitRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTokenDescription: anObject	self visitReferenceDescription: anObject! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'kph 6/9/2008 17:51'!asAccessor	^ MAChainAccessor accessors: self! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'jf 10/5/2009 08:40'!moveDown: anObject	| first second |	first := self findFirst: [ :value | value == anObject ].	second := (first > 0 and: [ first < self size ])		ifTrue: [ first + 1 ]		ifFalse: [ ^ first ].	self swap: first with: second.	^ second! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'jf 10/5/2009 08:38'!moveUp: anObject	| first second |	first := self findFirst: [ :value | value == anObject ].	second := first > 1 ifTrue: [ first - 1 ] ifFalse: [ ^ first ].	self swap: first with: second.	^ second! !!Symbol methodsFor: '*magritte-model-converting' stamp: 'lr 4/10/2008 13:33'!asAccessor	^ MASelectorAccessor selector: self! !!Symbol methodsFor: '*magritte-model-testing' stamp: 'lr 3/27/2006 17:44'!isDescriptionDefinition	"Answer wheter the receiver is a method selector following the naming conventions of a description definition."	^ self isDescriptionSelector		and: [ self isUnary ]! !!Symbol methodsFor: '*magritte-model-testing' stamp: 'AvO 3/12/2012 16:40'!isDescriptionExtension: aSelector	"Answer wheter the receiver is a method selector following the naming conventions of a description extension to aSelector."	^ self isDescriptionSelector		and: [ self numArgs = 1		and: [ self beginsWithSubCollection: aSelector ] ]! !!Symbol methodsFor: '*magritte-model-testing' stamp: 'AvO 3/12/2012 16:40'!isDescriptionSelector	"Answer wheter the receiver is a method selector following the naming conventions of a  description selector."	^ self ~= #description		and: [ self beginsWithSubCollection: #description ]! !!ArrayedCollection methodsFor: '*magritte-model' stamp: 'lr 7/31/2007 21:29'!copyWithAll: aCollection	^ (self species new: self size + aCollection size)		replaceFrom: 1 to: self size with: self startingAt: 1;		replaceFrom: self size + 1 to: self size + aCollection size with: aCollection startingAt: 1;		yourself! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/16/2009 13:39'!magritteAllSubInstancesOf: aClass do: aBlock	"Evaluate the aBlock for all instances of aClass and all its subclasses."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/16/2009 13:33'!magritteClassNamed: aString	"Return the class named aString, nil if the class can't be found."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/15/2009 18:35'!magritteColorClass	"Return a Color class"		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/16/2009 11:29'!magritteEvaluate: aBlock onUnhandledErrorDo: errorBlock	"Evaluate aBlock. If an Error is signaled and is not handled higher up the	stack, evaluate errorBlock with the Error instead of opening a debugger."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/17/2009 17:09'!magritteEvaluatorClassFor: aClass	"Answer an evaluator class appropriate for evaluating expressions in the 	context of this class."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/15/2009 18:13'!magritteRegister: anObject forMethodChangeNotificationsUsing: selector	"Register anObject with the system to be notified whenever a method is	added, removed, or modified. When this happens, the specified selector	should be called on anObject."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/16/2009 14:27'!magritteTimeStampClass	"Return the platform's TimeStamp class. It is currently assumed that all platforms	have one, though this may not be correct and could require moving timestamp stuff	to its own package in order to resolve."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/16/2009 13:31'!magritteUniqueObject	"Answer a random object, such as a UUID, that is extremely likely to	be unique over space and time."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/15/2009 18:14'!magritteUnregister: anObject forMethodChangeNotificationsUsing: selector	"Unregister anObject with the system for notification whenever a method is	added, removed, or modified. anObject should no longer receive notifications	using the specified selector."		self subclassResponsibility! !ProtoObject subclass: #MAProxyObject	instanceVariableNames: 'realSubject'	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Utility'!!MAProxyObject commentStamp: 'lr 5/17/2006 15:29' prior: 0!I represent an abstract proxy object, to be refined by my subclasses.!MAProxyObject subclass: #MADynamicObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Magritte-Model-Utility'!!MADynamicObject commentStamp: 'lr 4/10/2007 21:08' prior: 0!A dynamic object can be used for almost any property within Magritte that is not static but calculated dynamically. This is a shortcut to avoid having to build context sensitive descriptions manually over and over again, however there are a few drawbacks: - Some messages sent to this proxy, for example ==#class== and ==#value==, might not get resolved properly.- Raising an unhandled exception will not always open a debugger on your proxy, because tools are unable to properly work with the invalid object and might even crash your image.!!MADynamicObject methodsFor: 'accessing' stamp: 'jf 10/28/2009 15:24'!realSubject	^ GRPlatform current		magritteEvaluate: super realSubject		onUnhandledErrorDo: [ :err | err return: nil ]! !!MAProxyObject class methodsFor: 'instance creation' stamp: 'jf 9/24/2009 13:08'!new	MAError signal: 'Objects of this class require a delegate. Use #on:.'! !!MAProxyObject class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!on: anObject	^ self basicNew realSubject: anObject! !!MAProxyObject methodsFor: 'copying' stamp: 'lr 5/17/2006 15:30'!copy	"It doesn't make sense to copy proxies in most cases, the real-subject needs to be looked up and will probably return a new instance on every call anyway."	^ self! !!MAProxyObject methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!doesNotUnderstand: aMessage	^ self realSubject		perform: aMessage selector		withArguments: aMessage arguments! !!MAProxyObject methodsFor: 'testing' stamp: 'lr 4/10/2007 21:42'!isNil	"This method is required to properly return ==true== if the ==realSubject== is ==nil==."	^ self realSubject isNil! !!MAProxyObject methodsFor: 'printing' stamp: 'lr 4/10/2007 21:42'!printOn: aStream	"Print the receiver on ==aStream== but within square-brackets to show that it is a proxied instance."	aStream nextPut: $[; print: self realSubject; nextPut: $]! !!MAProxyObject methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!printString	^ String streamContents: [ :stream | self printOn: stream ]! !!MAProxyObject methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!realSubject	^ realSubject! !!MAProxyObject methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!realSubject: anObject	realSubject := anObject! !!Class methodsFor: '*magritte-model-configuration' stamp: 'lr 5/17/2006 15:47'!descriptionContainer	"Return the default description container."	^ MAPriorityContainer new		label: self label;		yourself! !!Class methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!label	"Answer a human-readable name of the receiving class. This implementation tries to be smart and return a nice label, unfortunately for a lot of classes this doesn't work well so subclasses might want to override this method and return soemthing more meaningfull to end-users."	| start input |	start := self name findFirst: [ :each | each isLowercase ].	input := (self name copyFrom: (1 max: start - 1) to: self name size)		readStream.	^ String streamContents: [ :stream |		[ input atEnd ] whileFalse: [			stream nextPut: input next.			(input atEnd or: [ input peek isLowercase ])				ifFalse: [ stream nextPut: Character space ] ] ]! !!Object class methodsFor: '*magritte-model-accessing' stamp: 'lr 3/27/2006 15:47'!description	^ MADescriptionBuilder for: self! !!Object methodsFor: '*magritte-model-accessing' stamp: 'DamienCassou 5/2/2010 19:32'!basicDescription	"Return the description of the receiver. Never override this method, instead modify #description."	^ self class description! !!Object methodsFor: '*magritte-model-accessing' stamp: 'DamienCassou 5/2/2010 19:31'!description	"Return the canonical description of the receiver. Subclasses might override this message to return instance-based descriptions."	^ self basicDescription! !!Object methodsFor: '*magritte-model-model' stamp: 'lr 9/23/2008 08:15'!initializeMagritte	"Initializes the receiving object with the default values of its description."	self description do: [ :each |		each isReadonly			ifFalse: [ self write: each default using: each ] ]! !!Object methodsFor: '*magritte-model-testing' stamp: 'lr 3/9/2006 11:31'!isDescription	^ false! !!Object methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!mementoClass	"Return a class to be used to remember or cache the receiver, namely a memento object."	^ MACheckedMemento! !!Object methodsFor: '*magritte-model-model' stamp: 'lr 3/9/2006 11:31'!readUsing: aDescription	"Dispatch the read-access to the receiver using the accessor of aDescription."	^ aDescription accessor read: self! !!Object methodsFor: '*magritte-model-model' stamp: 'lr 3/9/2006 11:31'!write: anObject using: aDescription	"Dispatch the write-access to the receiver of anObject using the accessor of aDescription."	aDescription accessor write: anObject to: self! !MAFileModel initialize!